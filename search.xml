<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学习使用PlantUML</title>
    <url>/2020/10/09/2020-10-09-%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8PlantUml/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>PlantUML</strong>是一个开源项目，支持通过文本快速绘制时序图，用例图，类图等多种软件图。</p>
<p>官方学习网站:<a href="https://plantuml.com/zh/">PlantUML学习</a></p>
<span id="more"></span>

<h2 id="使用PlantUML"><a href="#使用PlantUML" class="headerlink" title="使用PlantUML"></a>使用PlantUML</h2><h3 id="在线使用"><a href="#在线使用" class="headerlink" title="在线使用"></a>在线使用</h3><p><a href="https://www.planttext.com/">PlantUML在线网址</a></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/plantuml_demo.png" alt="plantumldemo"></p>
<h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><p>下载安装Visual Studio Code后，再安装相关插件。</p>
<p>文件-首选项-扩展，安装Markdown Preview Enhanced 和Markdown Preview Mermaid Support插件。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vscode_useplantuml1.png" alt="plantumldemo"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vscode_useplantuml2.png" alt="plantumldemo"></p>
<h2 id="学习用typora怎么画图"><a href="#学习用typora怎么画图" class="headerlink" title="学习用typora怎么画图"></a>学习用typora怎么画图</h2><p><a href="https://xw.qq.com/cmaid/20200808A00REF00">Typora 使用小技巧</a></p>
]]></content>
      <tags>
        <tag>PlantUML</tag>
        <tag>常用工具</tag>
      </tags>
  </entry>
  <entry>
    <title>理解会话与请求</title>
    <url>/2020/10/20/2020-10-20-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E7%90%86%E8%A7%A3%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章介绍android相机会话与请求的相关知识。包括：</p>
<ul>
<li>Camera管道机制</li>
<li>会话如何使用</li>
<li>请求如何下发</li>
</ul>
<h2 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h2><p>一个安卓设备上有多个摄像头，每一个设备对应一个<a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice">CameraDevice</a>，每一个Camera Device可以同时输出多路数据流。</p>
<span id="more"></span>
<p>通常应用使用到的流数据包括有预览流，拍照流，录像流，和回调流这样几种流。其中预览流会直接送显，拍照流一般会保存为图片，录像流是存储为视频，回调流是应用可以拿到每一帧数据，自己再做进一步处理。<br>一个相机设备，同时输出多路流，我们可以理解为对相机生产的RAW图进行并发处理。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/raw.png" alt="Raw并发处理"><br>每种数据流有它对应的输入格式。<br>Android Camera Framework图像数据是通过管道机制流转，创建CameraCaptureSession建立上层与底层CaneraDevice交流的管道。</p>
<h2 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h2><p>CameraCaptureSession用来描述和管理对应CameraDevice所有创建好的管道。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/session_pipelines.png" alt="Camera pipelines"></p>
<p>CameraCaptureSession通过传入对应的Surface列表创建出对应的管道，Session一但被创建好后，不能添加和移除管道。Session整个生命周期内，可以捕获一次或者多次请求。<br>每一个管道之所以可以将输入的数据转换成对应的图像格式，是因为管道建立时候是根据对应输出目标Surface创建了对应的输出流。<br>Session构造方式：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>函数定义</th>
</tr>
</thead>
<tbody><tr>
<td><code>void</code></td>
<td><code>createCaptureSession(SessionConfiguration config)</code>Create a new <code>CameraCaptureSession</code> using a <code>SessionConfiguration</code> helper object that aggregates all supported parameters.</td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>createCaptureSession(List outputs, CameraCaptureSession.StateCallback callback, Handler handler)</code><em>This method was deprecated in API level 30. Please use <code>createCaptureSession(android.hardware.camera2.params.SessionConfiguration)</code> for the full set of configuration options available.</em></td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>createCaptureSessionByOutputConfigurations(List outputConfigurations, CameraCaptureSession.StateCallback callback, Handler handler)</code><em>This method was deprecated in API level 30. Please use <code>createCaptureSession(android.hardware.camera2.params.SessionConfiguration)</code> for the full set of configuration options available.</em></td>
</tr>
<tr>
<td><code>abstract void</code></td>
<td><code>createConstrainedHighSpeedCaptureSession(List outputs, CameraCaptureSession.StateCallback callback, Handler handler)</code><em>This method was deprecated in API level 30. Please use <code>createCaptureSession(android.hardware.camera2.params.SessionConfiguration)</code> for the full set of configuration options available.</em></td>
</tr>
</tbody></table>
<p>可以看到有些构造方式已经在最新的SDK中被遗弃了。</p>
<h2 id="CaptureaRequest"><a href="#CaptureaRequest" class="headerlink" title="CaptureaRequest"></a>CaptureaRequest</h2><p>CaptureaRequest包含一个Builder内部类，通过Builder.build()函数可以创建CaptureRequest对象。</p>
<p>通常的使用的步骤：</p>
<ol>
<li>通过CameraDevice.createCaptureRequest(@RequestTemplate int templateType) 创建builder对象。</li>
<li>通过builder. addTarget(@NonNull Surface outputTarget) 为请求添加目标消费者。</li>
<li>通过Builder.build()函数创建CaptureaRequest对象。</li>
<li>创建 CameraCaptureSession.CaptureCallback 回调函数和处理回调的子线程Handler。</li>
<li>通过CameraCaptureSession请求下发的函数提交请求，例如 setRepeatingRequest(CaptureRequest, CaptureCallback, Handler) 提交一个预览请求。</li>
</ol>
<p>在CaptureRequest中定义了大量用于请求设置的TAG属性，请求中的这些属性会通过metadata下发到HAL被执行。</p>
<p>相机应用最常见的场景就是预览过程中下发一个拍照命令，捕获一张照片保存下来，这种情况下不需要停止正在进行预览，只需要下发一个非重复的拍照请求。需要注意的是，这种场景下，创建会话里一定是同时包含了预览和拍照的Surface，因为请求的目标Surface一定是已经保存在会话中的，预览请求的优先级低于拍照请求。</p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖反转</title>
    <url>/2020/10/30/2020-10-30-%E4%BE%9D%E8%B5%96%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<p>多态应该是面向对象编程范式，提供了最强大的能力，多态使得依赖反转成为了可能。</p>
<p>没有多态以前，高层函数要调用底层函数是一定要依赖于底层，再直接调用它定义函数。这种依赖是必须的，不同语言用不同的方式来实现这种依赖，C用include导入头文件，Java用import导入包名，C#用using导入命名空间。<br>但是有了多态这种关系就被打破了。</p>
<span id="more"></span>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/dependency_inversion.png" alt="依赖翻转案例"><br>A模块为了调用B模块的能力，第一幅图从A依赖B，但是通过依赖反转，A模块通过定义接口依赖于抽象接口，B模块去实现接口，这样依赖，A不再依赖于B模块，而B模块依赖于A模块的抽象接口了。<br>结合上面的内容，最后再体会下依赖反转原则的定义，就比较好理解了：<br>    1.高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。<br>    2.抽象接口不应该依赖于具体的实现和具体实现，而具体的实现应该依赖于抽象接口。<br><strong>面向对象编程到底是什么？业界在这个问题上存在很多不同的说法和意见，然后对于一个软件架构师来说，其含义应该是非常明确的，面向对象编程就是以多态的手段对源代码中的依赖关系进行控制的能力，这种能力让软件加入是可以构建出某种插件式架构，让高层策略性组建与底层实现组件相分离，底层祖先可以被编译成插件，实现独立与高层组建的开发和部署。</strong></p>
]]></content>
      <tags>
        <tag>编程</tag>
        <tag>依赖反转</tag>
      </tags>
  </entry>
  <entry>
    <title>曝光介绍</title>
    <url>/2021/01/16/2021-01-16-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E6%9B%9D%E5%85%89%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>曝光的英文是Exposure，一张照片的曝光度决定了相机拍摄的照片明暗程度。曝光通常只由三个相机设置决定：光圈、快门速度和ISO。<br>相机感光元件通过感应物体反射的光信号，记录下一个个像素信息，组成一张完整的图片。曝光直接影响到一张图片的质量，拍摄者想要拍出一张好的照片，既需要保证感光元件接受到的光信号不能过强（曝光过度），也要保证不能太弱（曝光不足）。那么照相机接受到多少光信号可以由哪些因素控制呢？这个其实和木桶收集雨水一个道理，降雨虽然是不可控的（类比光源强度不可控），我们依然可以控制木桶宽度，木桶在雨中接雨水的时间和希望收集的雨量。</p>
<h2 id="曝光三角形"><a href="#曝光三角形" class="headerlink" title="曝光三角形"></a>曝光三角形</h2><p>光圈就像木桶的宽度，决定了光通量大小。<br>快门速度就像决定了木桶在雨中搁置的时长一样，可以决定曝光时间。<br>ISO：数码相机中表示CCD或者CMOS感光元件的感光速度，或者说对给定光亮的敏感度，数值越高，就说明感光元器件的感光能力越强。公式：H*S=0.8,S代表感光度，H代表曝光量。实际上，如果感光度越高，对曝光量的要求就越小。</p>
<span id="more"></span>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/exposure_triangle.png" alt="曝光三角形"><br>通过，对上面三个控制量的不同组合可以实现相同的曝光，但是不同组合也会影响其他图像属性。例如，光圈影响景深，快门速度影响运动模糊，ISO速度影响图像噪点。<br>详细内容可以通过下面这篇文章学习：<a href="https://www.cambridgeincolour.com/tutorials/camera-exposure.htm">camera-exposure</a></p>
<h2 id="光圈"><a href="#光圈" class="headerlink" title="光圈"></a>光圈</h2><p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/dog_tree.jpg" alt="景深示意图"></p>
<p>第一行表示景深，从左，依次往右景深变得越来越浅，也就是背景越来越模糊。<br>光圈越大，景深越浅，也就是图片的背景越模糊，光圈越小，景深越深越就是图片的背景越清晰。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/depth_of_field.gif" alt="景深示意图"></p>
<h2 id="快门速度"><a href="#快门速度" class="headerlink" title="快门速度"></a>快门速度</h2><p>快门速度可以决定曝光时间。<br>从数字上看，快门速度对曝光的影响可能三种相机设置中最简单的：它与进入相机的光线量正好是1比1的关系。例如，当爆发时间增加一倍时，进入相机的光通量也会增加一倍。这也是一种可能性范围最广的设置。</p>
<table>
<thead>
<tr>
<th align="center">Shutter Speed</th>
<th align="center">Typical Examples</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1 - 30+ seconds</td>
<td align="center">用于在三脚架上拍摄夜景和低光照片</td>
</tr>
<tr>
<td align="center">2 - 1/2 second</td>
<td align="center">为流动的水面增添丝滑感，在三脚架上拍摄风景照片，增强景深。</td>
</tr>
<tr>
<td align="center">1/2 to 1/30 second</td>
<td align="center">为移动的被摄体的背景添加运动模糊 仔细拍摄带有稳定功能的手持照片。</td>
</tr>
<tr>
<td align="center">1/50 - 1/100 second</td>
<td align="center">典型的手持照片，没有大幅变焦</td>
</tr>
<tr>
<td align="center">1/250 - 1/500 second</td>
<td align="center">定格日常运动/动作被摄体的动作 使用大幅变焦（长焦镜头）的手持照片。</td>
</tr>
<tr>
<td align="center">1/1000 - 1/4000 second</td>
<td align="center">冻结极快的、近距离的被摄体运动。</td>
</tr>
</tbody></table>
<h2 id="ISO"><a href="#ISO" class="headerlink" title="ISO"></a>ISO</h2><p>ISO速度决定了相机对入射光线的敏感程度。与快门速度类似，它也与曝光的增加或减少为1比1相关。一般来说，哎呀，时值越低相片质量越高，像这些细节表现越好，因为这样做的is速度会显著增加图像噪点。因此，通常只有在无法获得所需的光圈和快门速度时，才会ISO速度从其最小值提高。</p>
]]></content>
      <tags>
        <tag>相机</tag>
        <tag>曝光</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan系列:环境安装</title>
    <url>/2021/02/27/2021-02-26-Vulkan%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h1 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1 安装环境"></a>1 安装环境</h1><h2 id="Vusual-Studio-2015-or-higher-version"><a href="#Vusual-Studio-2015-or-higher-version" class="headerlink" title="Vusual Studio 2015 or higher version"></a>Vusual Studio 2015 or higher version</h2><p>建议去官网下载，我自己用的是早期在学校做项目时候自己保存在百度网盘上的一份安装包。</p>
<p>链接: <a href="https://pan.baidu.com/s/1gfu64eSLUngNNam7FtNmXA">https://pan.baidu.com/s/1gfu64eSLUngNNam7FtNmXA</a> 提取码: qmgv</p>
<h2 id="vulkan驱动程序"><a href="#vulkan驱动程序" class="headerlink" title="vulkan驱动程序"></a>vulkan驱动程序</h2><p>大部分硬件厂商已经在默认的驱动安装包中包含了Vulkan的支持</p>
<span id="more"></span>
<h2 id="安装python"><a href="#安装python" class="headerlink" title="安装python"></a>安装python</h2><p>建议去官网下载，这里提供另一个下载路径。</p>
<p><a href="http://www.51xiazai.cn/soft/14542.htm">python3.9下载</a></p>
<p>安装过程中选择添加环境变量到PATH，如果没有的话，安装后需要自行添加。</p>
<p>查看安装结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;python --version</span><br><span class="line">Python 3.9.0</span><br></pre></td></tr></table></figure>

<h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>下载位置<a href="https://cmake.org/files/">https://cmake.org/files/</a> </p>
<p>太慢的话 我在下面链接里下载了一个腾讯软件中心的版本</p>
<p><a href="https://pc.qq.com/detail/11/detail_23371.html">Cmake下载</a></p>
<p>安装过程中选择添加环境变量到PATH，如果没有的话，安装后需要自行添加。</p>
<p>查看安装结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;cmake --version</span><br><span class="line">cmake version 3.15.5</span><br><span class="line"></span><br><span class="line">CMake suite maintained and supported by Kitware (kitware.com/cmake).</span><br></pre></td></tr></table></figure>

<h2 id="LunarG-sdk"><a href="#LunarG-sdk" class="headerlink" title="LunarG sdk"></a>LunarG sdk</h2><p>下载路径：<a href="https://vulkan.lunarg.com/sdk/home#windows">LunarG sdk官网下载</a></p>
<p>sdk的默认安装路径C:\VulkanSDK\版本。安装成功后，SDK的bin目录会自动添加到系统的环境变量PATH中，还会添加一个新的环境变量VK_SDK_PATH，指向sdk安装路径。</p>
<p>安装程序还会降Vulkan加载器（vulkan-1.dll）添加到C:\Windows\System32<br>安装程序后不知道为啥，C:\Windows\System32没有vulkan-1.dll，只有一个vulkan-1-999-0-0-0.dll，导致我运行C:\VulkanSDK\1.2.141.0\Bin\vkcube.exe 运行失败。所以我把vulkan-1-999-0-0-0.dll复制一份并改名为vulkan-1.dll。</p>
<p>同样的需要将 C:\Windows\SysWOW64里面的ulkan-1-999-0-0-0.dll复制一份并改名为vulkan-1.dll。不然后续调试过程中会报找不到vulkan-1.dll错误。</p>
<h1 id="2-编译调试Samples"><a href="#2-编译调试Samples" class="headerlink" title="2 编译调试Samples"></a>2 编译调试Samples</h1><p>LunarG sdk中包含有大量vulkan学习的案例，可以通过cmake构建案例工程并进行调试。</p>
<p>进入<code>C:\VulkanSDK\1.2.141.0\Samples</code>文件夹,执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir build2</span><br><span class="line">cd build2</span><br><span class="line">Cmake -G &quot;Visual Studio 14 Win64&quot; ..</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vulkan/1618013138890.png" alt="点乘公式"></p>
<p>打开VULKAN-SAMPLES.sln，并且分别选择debug和release两种方式重新生成（rebuild）所有的项目</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vulkan/1618013720687.png" alt="点乘公式"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vulkan/1618013703546.png" alt="点乘公式"></p>
<p>接下来，可以对项目进行调试。例如下图查看并运行15-draw_cube项目。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vulkan/1618014086459.png" alt="点乘公式"></p>
]]></content>
      <tags>
        <tag>Vulkan</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Vulkan系列:配置开发环境</title>
    <url>/2021/02/27/2021-02-26-Vulkan%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="配置vulkan开发环境"><a href="#配置vulkan开发环境" class="headerlink" title="配置vulkan开发环境"></a>配置vulkan开发环境</h1><p>开发工具：Visual Studio</p>
<h2 id="1-VC-目录"><a href="#1-VC-目录" class="headerlink" title="1 VC++目录"></a>1 VC++目录</h2><p>需要修改<strong>包含目录</strong>和<strong>库目录</strong>。</p>
<p><img src="https://gitee.com/hangliebe/blog/raw/master/pic/1606751963707.png" alt="1606751963707"></p>
<p>包含目录中添加C:\VulkanSDK\1.2.141.0\Include</p>
<span id="more"></span>
<p>库目录中添加C:\VulkanSDK\1.2.141.0\Bin32和C:\VulkanSDK\1.2.141.0\Lib32</p>
<p><img src="https://gitee.com/hangliebe/blog/raw/master/pic/1606752030227.png" alt="1606752030227"></p>
<h2 id="2-链接器"><a href="#2-链接器" class="headerlink" title="2 链接器"></a>2 链接器</h2><p>链接器-输入：添加vulkan-1.lib，同样需要修改Win32和Win64平台。</p>
<p><img src="https://gitee.com/hangliebe/blog/raw/master/pic/1606752144902.png" alt="1606752144902"></p>
]]></content>
      <tags>
        <tag>Vulkan</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>构建系统学习</title>
    <url>/2021/02/28/2021-02-28-%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>一般来说，<strong>元构建系统</strong>生成构建文件，<strong>构建工具</strong>进一步将其编译构建生成目标文件。</p>
<h1 id="元构建系统GN"><a href="#元构建系统GN" class="headerlink" title="元构建系统GN"></a>元构建系统GN</h1><p>GN是一种元构建系统，用于生成Ninja构建文件，然后ninja根据.ninja文件执行编译构建并生成目标文件。GN的全拼：Generate Ninja。</p>
<p>常见的元构建系统有cmake,gn等，可以指定编译器和链接器完成编译生成目标文件。</p>
<p>编译器：gcc,msvc，clang和llvm等。</p>
<p>连接器：lld和llvm等。</p>
<span id="more"></span>
<h1 id="构建工具ninja"><a href="#构建工具ninja" class="headerlink" title="构建工具ninja"></a>构建工具ninja</h1><p>ninja是一个轻量级的构建工具，和make类似，构建速度相对make更快。一般在Unix/Linux上的程序通过make/makefile来构建编译，而Ninja通过将编译任务并行组织，大大提高了构建速度。 </p>
<p>常见构建方案：cmake+ninja构建，gn+ninja构建.</p>
<p>ninja可以很好的组合<a href="https://code.google.com/p/gyp">gyp</a>和<a href="http://www.cmake.org/">CMake</a>一起使用，后者为其生成.ninja文件。</p>
<p>ninja项目的最终编译产出物是一个可执行文件ninja。</p>
<h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><h2 id="ninja下载与编译"><a href="#ninja下载与编译" class="headerlink" title="ninja下载与编译"></a>ninja下载与编译</h2><p> 预装 <a href="https://github.com/ellson/graphviz">graphviz</a>及其开发库，<a href="https://code.google.com/p/googletest">gtest</a>，<a href="http://www.git-scm.com/">git</a>、<a href="http://re2c.org/">re2c</a>和<a href="http://www.python.org/">python</a> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/ninja &amp;&amp; cd ~/ninja</span><br><span class="line">git clone https://github.com/martine/ninja</span><br><span class="line">cd ninja</span><br><span class="line">python ./bootstrap.py</span><br></pre></td></tr></table></figure>

<h2 id="gn下载"><a href="#gn下载" class="headerlink" title="gn下载"></a>gn下载</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">sudo apt-get install clang</span><br><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/gn.googlesource.com/gn</span></span><br><span class="line">cd gn</span><br><span class="line">python build/gen.py</span><br><span class="line">ninja -C out</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>GN</tag>
        <tag>ninja</tag>
      </tags>
  </entry>
  <entry>
    <title>高效使用VIM</title>
    <url>/2021/02/28/2021-02-28-%E9%AB%98%E6%95%88%E4%BD%BF%E7%94%A8VIM/</url>
    <content><![CDATA[<h1 id="1-安装ctags"><a href="#1-安装ctags" class="headerlink" title="1 安装ctags"></a>1 安装ctags</h1><p>ctags用于快速定位，跳转代码</p>
<h1 id="2-配置-Taglist-和NERDTree"><a href="#2-配置-Taglist-和NERDTree" class="headerlink" title="2 配置 Taglist 和NERDTree"></a>2 配置 Taglist 和NERDTree</h1><h2 id="下载Taglist"><a href="#下载Taglist" class="headerlink" title="下载Taglist"></a>下载Taglist</h2><p><a href="http://www.vim.org/scripts/script.php?script_id=273">taglist下载链接</a></p>
<p>下载下来后，unzip taglist_46.zip 到~/.vim</p>
<span id="more"></span>
<h2 id="下载NERDTree"><a href="#下载NERDTree" class="headerlink" title="下载NERDTree"></a>下载NERDTree</h2><p><a href="http://www.vim.org/scripts/script.php?script_id=1658">NERDTree下载链接</a></p>
<p>下载下来后，NERD_tree.zip 到~/.vim</p>
<p>安装taglist前先安装ctags，否则会打印Plugin is not loaded的错。</p>
<h1 id="3-配置vimrc"><a href="#3-配置vimrc" class="headerlink" title="3 配置vimrc"></a>3 配置vimrc</h1><p>创建并添加以下内容到～/.vimrc</p>
<p><em>可以根据自己的喜好配置</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">filetype plugin on</span><br><span class="line">let NerdtREEwINpOS=&quot;right&quot;</span><br><span class="line">nmap&lt;F8&gt;:TlistToggle&lt;CR&gt;</span><br><span class="line">nmap&lt;F9&gt;:NERDTreeToggle&lt;CR&gt;</span><br><span class="line">set mouse=a</span><br><span class="line"># 设置高亮光标行</span><br><span class="line">set cursorline</span><br><span class="line">hi CursorColumn cterm=NONE ctermbg=darked ctermfg=white guibg=darked guifg=white</span><br><span class="line">#与C语言语法一致</span><br><span class="line">set cindent </span><br><span class="line"></span><br><span class="line">set number</span><br><span class="line">#自动补全</span><br><span class="line">set completeopt=longest,menu</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>linux</tag>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>向量的点乘与差乘</title>
    <url>/2021/02/28/2021-03-01-%E5%90%91%E9%87%8F%E7%9A%84%E7%82%B9%E4%B9%98%E4%B8%8E%E5%B7%AE%E4%B9%98/</url>
    <content><![CDATA[<p>PS:如果公式不能正常显示，请使用chrome添加GitHub with MathJax插件</p>
<h1 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h1><p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/point_multiplication_formula.png" alt="点乘公式"></p>
<p>点乘的<strong>结果 是一个数值</strong>，可以告诉我们向量的方向性。<strong>向量点乘大于0代表两个向量方向基本一致，等于0代表垂直，小于0代表方向相反</strong>。也可以反映两个向量有多接近，值越大说明两个向量越接近，值越小表明越趋于相反。<br><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/point_multiplication_formula2.png" alt="点乘公式2"></p>
<h1 id="叉乘"><a href="#叉乘" class="headerlink" title="叉乘"></a>叉乘</h1><span id="more"></span>
<p><strong>叉乘结果得到另外一个向量</strong>。<strong>a b</strong>差乘的结果垂直于<strong>a</strong>和<strong>b</strong>，方向可以通过右手螺旋定则得到。<strong>a</strong>x<strong>b</strong>伸出右手，四指指向<strong>a</strong>方向，再向<strong>b</strong>弯曲四指，此时大拇指指向的方向为叉乘方向。</p>
<p>通过叉乘可以得到一个三维空间的坐标系。在一个三维空间里，我们给定x轴和y轴,可以差乘得到z轴。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/cross_product.gif" alt="图片"></p>
<h2 id="叉乘的用处？"><a href="#叉乘的用处？" class="headerlink" title="叉乘的用处？"></a>叉乘的用处？</h2><p>叉乘可以用来判断向量的左右关系，判断内外关系。这个在计算机图形学中非常有用，例如光栅化过程中就需要知道点是否在渲染区域里。<br><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/cross_product_formula.png" alt="叉乘公式"></p>
]]></content>
      <tags>
        <tag>Vulkan</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>Android基础系列:编译与反编译</title>
    <url>/2021/01/16/2021-03-01-%20%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h1 id="1-编译"><a href="#1-编译" class="headerlink" title="1 编译"></a>1 编译</h1><h2 id="1-1-编译器"><a href="#1-1-编译器" class="headerlink" title="1.1 编译器"></a>1.1 编译器</h2><p>&emsp;&emsp;计算机只能识别01,无法读懂程序员用java等高级语言写出的if else代码,所以这些代码在使用之前一定要转换成可以执行的二进制文件。</p>
<p>&emsp;&emsp;这也是编译器存在的原因。编译器是将高级语言编写的程序解析成计算机需要的详细机器语言指令集的程序。<br>编译器是一个程序,其工作是转换源码为可执行代码。</p>
<span id="more"></span>
<p>&emsp;&emsp;可执行代码是用计算机的本机语言或机器语言表示的代码。这种语言由数字代码(01)表示的详细指令组成。不同的计算机具有不同的机器语言。</p>
<h2 id="1-2-java编译器"><a href="#1-2-java编译器" class="headerlink" title="1.2 java编译器"></a>1.2 java编译器</h2><p>&emsp;&emsp;JDK安装后,在bin文件夹下有一个javac.exe的应用程序,这个程序可以简单看作是java编译器。</p>
<p>&emsp;&emsp;javac.exe将java源码(java文件)编译成二进制字节码文件(.class文件),这是一种特殊的二进制文件,它是JVM的”机器语言”。</p>
<p>&emsp;&emsp;所以说javac.exe并没有将java源码直接翻译成计算机可以识别的机器语言,而是翻译成了java虚拟机识别的语言,而jvm将其再进一步翻译成对应的机器语言,这是java程序实现跨平台的原因,因为java程序可以跑在任何安装了jvm的计算机上。</p>
<p>&emsp;&emsp;扩展学习《<a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" title="深入浅出JIT编译器">深入浅出JIT编译器</a>》 </p>
<h2 id="1-3-Android-编译器"><a href="#1-3-Android-编译器" class="headerlink" title="1.3 Android 编译器"></a>1.3 Android 编译器</h2><p>&emsp;&emsp;我们了解到JVM是java程序的运行环境,用来运行java的字节码程序。google为android平台专门设计了运行环境,以前是Dalvik,现在是ART(Android Runtime)<br><img src="https://gitee.com/hangliebe/blog/raw/master/javaLearning/picture/android_architecture_diagram.jpg" alt="android 架构图"></p>
<h1 id="2-反编译"><a href="#2-反编译" class="headerlink" title="2 反编译"></a>2 反编译</h1><h2 id="2-1反编译工具"><a href="#2-1反编译工具" class="headerlink" title="2.1反编译工具"></a>2.1反编译工具</h2><p>（1）dex2jar</p>
<p>&emsp;&emsp;从下面链接可以下载最新的<a href="https://github.com/pxb1988/dex2jar/releases" title="dex2jar工具">dex2jar工具</a>：</p>
<p>（2）jadx</p>
<p>&emsp;&emsp;下载<a href="https://github.com/skylot/jadx" title="jadx工具">jadx工具</a>,下载并解压,执行jadx-0.7.1\binjadx-gui.bat, 将反编译出的jar包拖进来就可以看到源码文件。</p>
<h2 id="2-2反编译步骤"><a href="#2-2反编译步骤" class="headerlink" title="2.2反编译步骤"></a>2.2反编译步骤</h2><p>1 解压出apk包中的classes.dex</p>
<p>2 使用的dex2jar工具中的d2j-dex2jar.bat 操作apk解压出来的classes.dex，得到classes-dex2jar.jar</p>
<p>3 使用jd-gui打开反编译出来的classes-dex2jar.jar,就可以看到所有的源码。</p>
]]></content>
      <tags>
        <tag>编译</tag>
        <tag>反编译</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>相机能力_开篇</title>
    <url>/2021/03/24/2021-03-24-%E7%9B%B8%E6%9C%BA%E8%83%BD%E5%8A%9B/</url>
    <content><![CDATA[<p>做多媒体相机开发很长一段时间了，需要在自己的笔记本上及时写好总结。比如：</p>
<p>1 Android相机的体系架构</p>
<p>2 相机服务的作用</p>
<p>3 相机的一些调试方法</p>
<p>4 ……</p>
]]></content>
      <tags>
        <tag>android相机</tag>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>使用FFmpeg</title>
    <url>/2021/03/24/2021-03-24-%E5%A4%9A%E5%AA%92%E4%BD%93%E9%9F%B3%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97_%E4%BD%BF%E7%94%A8FFmpeg/</url>
    <content><![CDATA[<h2 id="视频格式"><a href="#视频格式" class="headerlink" title="视频格式"></a>视频格式</h2><p>视频文件本身是一个包含了音频和视频的容器，还可能包含字幕等其他信息。常见的视频文件格式：MPEG格式、AVI格式、nAVI格式、ASF格式、WMV格式、MOV格式、3GP格式。</p>
<h2 id="编码格式codec"><a href="#编码格式codec" class="headerlink" title="编码格式codec"></a>编码格式codec</h2><p>不同的编码格式有不同的压缩率，会影响文件的大小和清晰度。<br>可以查看FFmpeg支持的视频文件格式：<br>ffmpeg -formats<br>常见的有版权的编码格式：</p>
<span id="more"></span>
<ul>
<li><p>H. 262</p>
</li>
<li><p>H. 264</p>
</li>
<li><p>H. 265</p>
</li>
</ul>
<p>常见的无版权编码格式</p>
<ul>
<li><p>VP8</p>
</li>
<li><p>VP9</p>
</li>
<li><p>AV1<br>常见的音频编码格式</p>
</li>
<li><p>Mp3</p>
</li>
<li><p>AAC</p>
</li>
</ul>
<p>查看编码格式<br>ffmpeg -codecs</p>
<h2 id="编码器encoders"><a href="#编码器encoders" class="headerlink" title="编码器encoders"></a>编码器encoders</h2><p>通过编码器可以对音视频进行编码和解码<br>ffmpeg有内置的编码器。<br>通过ffmpeg -encoders查看已安装的编码器</p>
<h2 id="ffmpeg常用工具"><a href="#ffmpeg常用工具" class="headerlink" title="ffmpeg常用工具"></a>ffmpeg常用工具</h2><p>ffmpeg中有三个工具，demuxer（解析文件）,parser（解析帧）和decoder（解码）.</p>
<h2 id="ffmpeg下载与安装"><a href="#ffmpeg下载与安装" class="headerlink" title="ffmpeg下载与安装"></a>ffmpeg下载与安装</h2><p>可以直接从官网进行下载，根据需要选择对应的系统版本。<a href="http://ffmpeg.org/download.html">http://ffmpeg.org/download.html</a></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/downloadffmpeg1.png" alt="下载FFmpeg图片1"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/downloadffmpeg2.png" alt="下载FFmpeg图片2"></p>
<p>下载解压后<code>ffmpeg-4.4-full_build\ffmpeg-4.4-full_build\bin</code>下有几个执行文件。</p>
<p>可以尝试使用 ffmpeg 对视频格式进行转换，比如一个mp4文件，想转为avi<br><code>ffmpeg -i test.avi output.mp4</code></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/testffmpeg.png" alt="下载FFmpeg图片2"></p>
]]></content>
      <tags>
        <tag>音视频</tag>
        <tag>FFmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>vulkan系列:推送常数</title>
    <url>/2021/04/05/2021-04-05-vulkan%E6%8E%A8%E9%80%81%E5%B8%B8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="推送常数说明"><a href="#推送常数说明" class="headerlink" title="推送常数说明"></a>推送常数说明</h2><p>推送常数是一种特殊的更新着色器常量数据的方法，它使用指令缓存的方式，而非资源的写入或者复制描述符来完成更新的操作。<br>推送常数提供了一种高速的优化方式，可以高效地更新流水线中的常量数据。<br>下面以一个例子来说明推送常数怎么使用</p>
<span id="more"></span>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>按键A和S可以切换顶点颜色</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/vulkan_2021_4_5_21_11_01.gif" alt="vulkan_变换颜色的三角形"></p>
<h2 id="定义推送常数资源"><a href="#定义推送常数资源" class="headerlink" title="定义推送常数资源"></a>定义推送常数资源</h2><p>着色器中的推送常数资源是通过关键字push_constant来定义的，它被用在布局当中定义一个推送常数块（push constant block）。如下图定义了一个pushcConstant的推送常数块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#version 450</span><br><span class="line">#extension GL_ARB_separate_shader_objects : enable</span><br><span class="line"></span><br><span class="line">layout(constant_id=0) const int ColorChange = 0;</span><br><span class="line"></span><br><span class="line">layout(push_constant) uniform pushCons&#123;</span><br><span class="line">    int level;</span><br><span class="line">&#125; pushcConstant;</span><br><span class="line"></span><br><span class="line">layout(location = 0) out vec3 fragColor;</span><br><span class="line"></span><br><span class="line">vec2 positions[3] = vec2[](</span><br><span class="line">    vec2(-0.5, 0.5),</span><br><span class="line">	vec2(0, -0.5),</span><br><span class="line">    vec2(0.5, 0.5)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">vec3 red = vec3(1.0, 0.0, 0.0);</span><br><span class="line">vec3 green = vec3(0.0, 1.0, 0.0);</span><br><span class="line">vec3 blue = vec3(0.0, 0.0, 1.0);</span><br><span class="line"></span><br><span class="line">vec3 colors[3] = vec3[]( red, green, blue);</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">	if (pushcConstant.level == 1)</span><br><span class="line">	   colors = vec3[](green, blue, red);</span><br><span class="line">	else if (pushcConstant.level == 2)</span><br><span class="line">	   colors = vec3[](blue, red, green);</span><br><span class="line">	else</span><br><span class="line">	   colors = vec3[]( red, green, blue);</span><br><span class="line">    gl_Position = vec4(positions[gl_VertexIndex], 0.0, 1.0);</span><br><span class="line">    fragColor = colors[gl_VertexIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="键盘交互"><a href="#键盘交互" class="headerlink" title="键盘交互"></a>键盘交互</h2><pre><code>void processInput(GLFWwindow* window) &#123;    
    if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS) &#123;
        std::cout &lt;&lt; &quot;PRESS KEY_S: &quot; &lt;&lt; GLFW_KEY_S &lt;&lt; std::endl;
        // 设置推送常数的值
        pushDatas[0].level--;
        if (pushDatas[0].level == 0) &#123;
            pushDatas[0].level = 3;
        &#125;
        RecorderCommandBuffer();
    &#125;
    if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS) &#123;
        std::cout &lt;&lt; &quot;PRESS KEY_S: &quot; &lt;&lt; GLFW_KEY_S &lt;&lt; std::endl;
        // 设置推送常数的值
        pushDatas[0].level++;
        if (pushDatas[0].level == 4) &#123;
            pushDatas[0].level = 1;
        &#125;
        RecorderCommandBuffer();
    &#125;
&#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Renderer::StartRender()</span><br><span class="line">&#123;</span><br><span class="line">	while (!glfwWindowShouldClose(mWindow)) &#123;</span><br><span class="line">		glfwPollEvents();</span><br><span class="line">	 	processInput(mWindow);</span><br><span class="line">        ………</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="更新流水线布局和推送常数"><a href="#更新流水线布局和推送常数" class="headerlink" title="更新流水线布局和推送常数"></a>更新流水线布局和推送常数</h2><p>更新流水线布局并设置推送常数的范围。推送常数的范围在单一流水线布局中是通过结构体VkPushConstantRange定义的。<br>更新资源数据：<br>1 分配一个指令缓存VkCommandBuffer cmdPushConstant，给资源数据设置合适的数据值，<br>2 执行vkCmdPushConstants（）更新资源数据，cmdPushConstant被作为第一个入参。</p>
<p>推送常数大小限制：推送常数的大小不可超过VkPhysicalDeviceProperties：：limits：：maxPushConstantsSize所定义的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Renderer::RecorderCommandBuffer()</span><br><span class="line">&#123;</span><br><span class="line">	// 判断推送常数的数量是否大于最大允许范围</span><br><span class="line">	int maxPushDataSize = mDeviceManager-&gt;workGpuProperties.limits.maxPushConstantsSize;</span><br><span class="line">	if (sizeof(pushDatas) &gt; maxPushDataSize) &#123;</span><br><span class="line">		Utils::Assert(&quot;Vulkan ERROR:Push data size is larger than maxPushConstantsSize!&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	for (size_t i = 0; i &lt; mCommandBuffer.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		VkCommandBufferBeginInfo beginInfo = &#123;&#125;;</span><br><span class="line">		beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;</span><br><span class="line">		beginInfo.flags = 0;</span><br><span class="line">	</span><br><span class="line">		CommandBufferMangager::BeginCmdBuffer(mCommandBuffer[i], &amp;beginInfo);</span><br><span class="line">	</span><br><span class="line">		VkRenderPassBeginInfo renderPassBeginInfo = &#123;&#125;;</span><br><span class="line">		renderPassBeginInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;</span><br><span class="line">		renderPassBeginInfo.renderPass = mRenderPass;</span><br><span class="line">		renderPassBeginInfo.framebuffer = mFrameBuffer[i];</span><br><span class="line">		renderPassBeginInfo.renderArea.offset = &#123; 0 , 0 &#125;;</span><br><span class="line">		renderPassBeginInfo.renderArea.extent = swapChainCreateInfo.imageExtent;</span><br><span class="line">	</span><br><span class="line">		vkCmdPushConstants(mCommandBuffer[i], mPipelineLayout,</span><br><span class="line">			VK_SHADER_STAGE_VERTEX_BIT,</span><br><span class="line">			0,</span><br><span class="line">			sizeof(pushDatas),</span><br><span class="line">			&amp;pushDatas);</span><br><span class="line">	</span><br><span class="line">		VkClearValue clearColor = &#123; 0.0f , 0.0f , 0.0f , 1.0f &#125;;</span><br><span class="line">		renderPassBeginInfo.clearValueCount = 1;</span><br><span class="line">		renderPassBeginInfo.pClearValues = &amp;clearColor;</span><br><span class="line">		vkCmdBeginRenderPass(mCommandBuffer[i], &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);</span><br><span class="line">		vkCmdBindPipeline(mCommandBuffer[i], VK_PIPELINE_BIND_POINT_GRAPHICS, mGraphicsPipeline);</span><br><span class="line">		vkCmdDraw(mCommandBuffer[i], 3, 1, 0, 0);</span><br><span class="line">		vkCmdEndRenderPass(mCommandBuffer[i]);</span><br><span class="line">	</span><br><span class="line">		CommandBufferMangager::EndCmdBuffer(mCommandBuffer[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>vulkan</tag>
        <tag>推送常数</tag>
      </tags>
  </entry>
  <entry>
    <title>应用无法获取相机tag</title>
    <url>/2021/04/08/2021-04-08-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96%E7%9B%B8%E6%9C%BAtag/</url>
    <content><![CDATA[<p>Camera应用Tag无法获取，首先检查Tag上报情况，如果已经上报，则进一步检查重复定义情况。</p>
<h2 id="Tag属性上报"><a href="#Tag属性上报" class="headerlink" title="Tag属性上报"></a>Tag属性上报</h2><p>adb shell dumpsys media.camera-&gt;camera in for. txt<br>检查Hal是否已经把应用无法获取的tag上报给了Framework层，如果没有，则需要底层适配。</p>
<h2 id="重复定义"><a href="#重复定义" class="headerlink" title="重复定义"></a>重复定义</h2><p>如果通过dump的信息确认tag已经上报，可以进一步检查是否存在tag属性重复定义的情况。</p>
<span id="more"></span>
<ul>
<li><p>底层对Tag定义进行排查，是否存在重复定义。</p>
</li>
<li><p>查看Android. request. available Character isticsKeys，看是否有相同的值。</p>
</li>
</ul>
<p>关键代码</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/getCameraCharacteristics.png" alt="getCameraCharacteristics"></p>
]]></content>
      <tags>
        <tag>相机</tag>
        <tag>问题分析</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体相机系列:认识相机</title>
    <url>/2021/04/13/2021-04-13-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E8%AE%A4%E8%AF%86%E7%9B%B8%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章为入门相机的同学简单介绍了相机的发展过程以及基本原理，这些基础知识其实很重要，可以帮助我们更好的理解相机拍摄出图的过程。</p>
<h2 id="1-小孔成像"><a href="#1-小孔成像" class="headerlink" title="1 小孔成像"></a>1 小孔成像</h2><p>小孔成像，我国的学者—<a href="https://baike.baidu.com/item/%E5%A2%A8%E7%BF%9F/850519">墨翟</a>（墨子）和他的学生，做了世界上第一个小孔成倒像的实验，解释了小孔成倒像的原因，指出了光沿直线进行的性质，早于牛顿2000多年就已经总结出相似的理论 。这是对光沿直线传播的第一次科学解释。</p>
<p>用一个带有小孔的板遮挡在墙体与物之间，墙体上就会形成物的倒影，我们把这样的现象叫小孔成像。前后移动中间的板，墙体上像的大小也会随之发生变化，这种现象说明了光沿直线传播的性质。</p>
<span id="more"></span>
<p>小孔成像就是相机最基础的原理。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/pinhole_imaging.png" alt="小孔成像"></p>
<h2 id="2-暗箱作画"><a href="#2-暗箱作画" class="headerlink" title="2 暗箱作画"></a>2 暗箱作画</h2><p>霍克尼是当今艺术领域最具影响力的大师之一，一生创作了大量腐蚀板画。这位大师在2012年出版的《隐秘的知识》一书中告诉读者，文艺复兴时代，像达芬奇，拉斐尔等一众艺术宗师们作画时都会利用小孔成像原理，通过透视镜装置来暗箱临摹。这种暗箱作画的方式，为相机得以发展做了重要铺垫。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/painting_in_dark_box.png" alt="暗箱操作"></p>
<h2 id="3-凸透镜"><a href="#3-凸透镜" class="headerlink" title="3 凸透镜"></a>3 凸透镜</h2><p>凸透镜具有屈光性，可以汇聚光线， 照相机运用凸透镜的成像规律可以使成像更清晰。1550年意大利的卡尔达诺就将双凸透镜置于原来的针孔位置上，得到了更好的映像效果。凸透镜也是如今相机必不可少的重要组成器件。</p>
<h2 id="4-感光材料"><a href="#4-感光材料" class="headerlink" title="4 感光材料"></a>4 感光材料</h2><p>暗箱作画虽然帮助画家大大提升了作画效率，但是依旧难以满足科学家和商人们对快速纪录影像的极致追求。既然光可以将物体的影像呈现在画板上，那有什么办法可以让“光照记录”可以永久保存下来呢？显然，要找到答案，就必须找到什么物质可以对光照产生某种化学反应就好了。</p>
<p>1825年，法国人将感光材料放进暗箱，拍摄了现存最早的照片。下面的照片名为《 窗外景色 》，话说曝光了8小时。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/first_picture.png" alt="第一张照片"></p>
<p>1888年，美国柯达公司生产了新型感光材料<a href="https://zh.wikipedia.org/wiki/%E5%BA%95%E7%89%87">胶卷</a>。胶卷用到的主要化学材料是卤化银， 卤化银感光材料的感光度比非银感光材料的高很多，加以它的感色范围宽，易于得到彩色图像，所以被作为相机感光的重要化学材料。 </p>
<h2 id="5-数码相机"><a href="#5-数码相机" class="headerlink" title="5 数码相机"></a>5 数码相机</h2><p>数码相机和普通相机最主要的区别就在于感光材料进化成了感光元件，感光元件将光学影像转换成电子数据，两种最广泛应用的感光元件：<a href="https://zh.wikipedia.org/wiki/%E6%84%9F%E5%85%89%E8%80%A6%E5%90%88%E5%85%83%E4%BB%B6">CCD</a>和<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%A3%9C%E5%BC%8F%E9%87%91%E5%B1%AC%E6%B0%A7%E5%8C%96%E7%89%A9%E5%8D%8A%E5%B0%8E%E9%AB%94">CMOS</a>。感光元件也就camera sensor，负责感光并转换输出最初的元数据文件，再经过DSP，ISP等图像数据处理单元，生成对用户友好可视的图像。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>现在，我们已经明白了，拍照过程实际上是相机对物体反射光线的记录过程，实际上物体本身的颜色并不是我们对其所感知的颜色，比如芒果是黄色的，并不是芒果本身是黄色，而恰恰因为芒果可以吸收其他光线，而反射了更多的黄色光，因此我们看到的芒果是黄色。 </p>
<p>要深入学习多媒体知识，我们需要对更多的关于光与颜色基础知识进行学习。</p>
<p>参考文档:</p>
<p>1 <a href="https://baike.baidu.com/item/%E5%B0%8F%E5%AD%94%E6%88%90%E5%83%8F/866213?fr=aladdin">百度词条_小孔成像</a></p>
<p>2  <a href="https://zh.wikipedia.org/wiki/%E7%85%A7%E7%9B%B8%E6%A9%9F">维基百科_照相机</a></p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体相机系列:相机使用</title>
    <url>/2021/04/15/2021-04-15-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E7%9B%B8%E6%9C%BA%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>系统多媒体主要包含音频，视频以及相机三大能力板块，相机能力是其中至关重要的一个，可以说所有与我们生活至关重要的那些app都离不开对相机功能的应用。</p>
<p>这篇文章作为相机能力的入门，对Android相机能力总结，开发者通过建立四大步骤的概念，可以很快了解到安卓相机能力如果使用。</p>
<span id="more"></span>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/camera_basic_use.png" alt="相机基础使用步骤"></p>
<h2 id="1-获取CameraManager"><a href="#1-获取CameraManager" class="headerlink" title="1 获取CameraManager"></a>1 获取CameraManager</h2><p>CameraManager 对象用于应用测管理相机设备信息，可以获取设备的基础属性能力，用于连接相机。通过下面接口可以获取CameraManager对象，之后就可以进一步去连接使用相机设备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CameraManager manager=(CameraManager)getSystemService(Context.CAMERA_SERVICE);</span><br></pre></td></tr></table></figure>

<h2 id="2-打开相机"><a href="#2-打开相机" class="headerlink" title="2 打开相机"></a>2 打开相机</h2><p>关键接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CameraManager:</span><br><span class="line">    String[] getCameraIdList();</span><br><span class="line">    void openCamera(String cameraId, final CameraDevice.StateCallback callback, Handler handler)</span><br></pre></td></tr></table></figure>

<p>getCameraIdList帮助获取当前可用的相机ID列表，包括逻辑摄像头和物理摄像头。openCamera帮助打开指定ID对应的相机设备，传入的ID可以是物理ID或者逻辑ID。</p>
<hr>
<p>说明：在相机的使用设计中，安卓提出了物理相机和逻辑相机的概念，每个物理相机对应一个实际的相机设备，而一个逻辑相机对应一个或者几个物理相机的组合，它是物理相机的软件抽象。通常，应用通过对逻辑相机下发命令去实际操作相机。</p>
<hr>
<p>openCamera执行的结果通过<code>CameraDevice.StateCallback</code>回调接口通知到应用侧，打开成功会回调此接口<code>public abstract void onOpened(@NonNull CameraDevice camera); </code>这样应用就可以获取到CameraDevice 对象。</p>
<h2 id="3-创建会话"><a href="#3-创建会话" class="headerlink" title="3 创建会话"></a>3 创建会话</h2><p>关于会话更多的知识可以阅读文章《<a href="https://hangliebe.gitee.io/2020/10/20/%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E7%90%86%E8%A7%A3%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%AF%B7%E6%B1%82/">理解会话与请求</a>》</p>
<p>关键接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CameraDevice:</span><br><span class="line">    void createCaptureSession(List&lt;**Surface**&gt; outputs, CameraCaptureSession.StateCallback callback, Handler handler);</span><br><span class="line"></span><br><span class="line">    void createCaptureSessionByOutputConfigurations( List&lt;**OutputConfiguration**&gt; outputConfigurations, CameraCaptureSession.StateCallback callback, Handler handler); </span><br></pre></td></tr></table></figure>

<p>上面两个创建会话的两个接口中较多使用的是第一个，会话创建成功就说明应用已经与底层相机硬件建立起了可以进行交流的通道。</p>
<p>创建会话执行的结果通过<code>CameraCaptureSession.StateCallback</code>回调接口通知到应用侧，创建成功会回调此接口  <code>public abstract void onConfigured(@NonNull CameraCaptureSession session); </code>这样应用就可以获取到CameraCaptureSession对象。</p>
<h2 id="4-下发请求"><a href="#4-下发请求" class="headerlink" title="4 下发请求"></a>4 下发请求</h2><p>会话建立起来了，应用就可以通过会话通道下发请求，通常请求包括预览，拍照和录像。</p>
<p>关键接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CameraCaptureSession:</span><br><span class="line">     int setRepeatingRequest(CaptureRequest request, CaptureCallback listener, Handler handler);</span><br><span class="line">     int capture(CaptureRequest request,CaptureCallback listener, Handler handler)</span><br><span class="line">     ……</span><br></pre></td></tr></table></figure>

<h3 id="CaptureRequest"><a href="#CaptureRequest" class="headerlink" title="CaptureRequest"></a>CaptureRequest</h3><p>应用与底层沟通的语言包是CaptureRequest，通过将自己的“述求”塞进一个个CaptureRequest对象，再调用对应的接口下发到底层。构建CaptureRequest对象要使用到其内部类CaptureRequest.Builder。使用步骤可以查看《<a href="https://hangliebe.gitee.io/2020/10/20/%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E7%90%86%E8%A7%A3%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%AF%B7%E6%B1%82/">理解会话与请求</a>》中的请求部分。</p>
<p>请求创建过程中需要添加Surface作为输出目标，这里的Surface必须是创建会话时候传入的Surface对象。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Demo案例：<a href="https://gitee.com/hangliebe/camera-sample">gitee案例地址</a></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/previewCamera.gif" alt="预览效果"></p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>UmlMaker——移动的UML设计</title>
    <url>/2021/04/24/2021-04-24-UmlMaker%E7%A7%BB%E5%8A%A8%E7%9A%84UML%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常常想要做一些软件设计，但是苦于没有PC时时在手，没有办法将自己的一些软件设计的想法及时记录下来。一直使用plantUml做软件图的绘制，就希望可以找到一款移动软件可以替代电脑，方便平时做图。我在华为和苹果的应用商城都找了下，没有找到称心的UML软件。</p>
<p>于是萌生了自己做一个的想法，这就是UmlMaker诞生的背景。</p>
<p>周六就开始自己在家做了起来，本来以为会很简单的，结果还是遇到了一些没有想到困难。</p>
<span id="more"></span>
<h2 id="UmlMaker"><a href="#UmlMaker" class="headerlink" title="UmlMaker"></a>UmlMaker</h2><p>我准备将代码开源到码云上<a href="https://gitee.com/hangliebe/uml_maker">UmlMaker</a>，下面是软件的设计。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/umlmaker/UmlMaker.png" alt="主图样例"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/umlmaker/UmlMaker_side.png" alt="侧边栏样例"></p>
<h2 id="如何加载网络图片？"><a href="#如何加载网络图片？" class="headerlink" title="如何加载网络图片？"></a>如何加载网络图片？</h2><p>我找了几种方法，都试了下，这耗费了我不少时间，最后还是选择了使用ImageLoader插件的方式，成功的加载出了图片。</p>
<p>下载了<a href="https://github.com/nostra13/Android-Universal-Image-Loader/blob/master/downloads/universal-image-loader-1.9.5.jar">jar包</a>，再进一步导入到工程里。</p>
<p>下面是一个简单使用的案例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void config() &#123;</span><br><span class="line">    // Create default imageLoader configuration parameters</span><br><span class="line">    ImageLoaderConfiguration configuration = ImageLoaderConfiguration</span><br><span class="line">            .createDefault(this);</span><br><span class="line">    //Initialize ImageLoader with configuration.</span><br><span class="line">    ImageLoader.getInstance().init(configuration);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void loadPic(String url) &#123;</span><br><span class="line">    ImageLoader.getInstance().loadImage(url, new SimpleImageLoadingListener()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onLoadingComplete(String imageUri, View view,</span><br><span class="line">                                      Bitmap loadedImage) &#123;</span><br><span class="line">            super.onLoadingComplete(imageUri, view, loadedImage);</span><br><span class="line">            imageView.setImageBitmap(loadedImage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="在java中调用JS代码"><a href="#在java中调用JS代码" class="headerlink" title="在java中调用JS代码"></a>在java中调用JS代码</h2><p>网上对此有相关的介绍和学习案例<a href="https://www.jianshu.com/p/f472c43c16db">JS in Android (Google V8)</a></p>
<p>我选择使用了J2V8的方式。</p>
<p>添加依赖项<code>implementation &#39;com.eclipsesource.j2v8:j2v8:5.0.103@aar&#39;</code>，再sync一下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public void testJsInJava(String str) &#123;</span><br><span class="line">        V8 runtime = V8.createV8Runtime();</span><br><span class="line">         runtime.executeVoidScript(&quot;&quot;</span><br><span class="line">                + &quot;var s = &#x27;&quot;+ str +&quot;&#x27;;\n&quot;</span><br><span class="line">                + &quot;s = unescape(encodeURIComponent(s));\n&quot;</span><br><span class="line">                + &quot;var arr = [];\n&quot;</span><br><span class="line">                + &quot;for (var i = 0; i &lt; s.length; i++) &#123;\n&quot;</span><br><span class="line">                + &quot;arr.push(s.charCodeAt(i));\n&quot;</span><br><span class="line">                + &quot;&#125;\n&quot;</span><br><span class="line">             //  + &quot;var compressor = new Zopfli.RawDeflate(arr);\n&quot;</span><br><span class="line">             //  + &quot;var compressed = compressor.compress();\n&quot;</span><br><span class="line">        );</span><br><span class="line">    </span><br><span class="line">        V8Object person = runtime.getObject(&quot;arr&quot;);</span><br><span class="line">        Log.d(TAG, &quot;result&quot;+ person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">```  </span><br><span class="line">## Zopfli算法</span><br><span class="line"></span><br><span class="line">Zopfli压缩算法是google[开源](https://github.com/google/zopfli)的一个用C语言编程的压缩库，可以进行非常好但很慢的deflate或zlib压缩。</span><br><span class="line"></span><br><span class="line">压缩数据的基本功能是zopfli.h中的ZopfliCompress。使用ZopfliOptions对象来设置影响速度和压缩的参数。使用ZopfliInitOptions函数将默认值先放在ZopfliOptions中。</span><br><span class="line"></span><br><span class="line">用这个算法主要是需要将plantuml文本数据提交前要先做压缩。</span><br><span class="line"></span><br><span class="line">## Android Studio基本设置</span><br><span class="line"></span><br><span class="line">build.gradle远端仓库设置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>buildscript {<br>    repositories {<br>        maven { url ‘<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;">http://maven.aliyun.com/nexus/content/groups/public/&#39;</a> }<br>        google()<br>        jcenter()</p>
<pre><code>&#125;
……
</code></pre>
<p>}<br>allprojects {<br>    repositories {<br>        maven { url ‘<a href="http://maven.aliyun.com/nexus/content/groups/public/&#39;">http://maven.aliyun.com/nexus/content/groups/public/&#39;</a> }<br>        google()<br>        jcenter()<br>    }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gradle.properties设置</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>systemProp.socks.proxyHost=127.0.0.1<br>systemProp.http.proxyHost=mirrors.opencas.cn<br>systemProp.https.proxyPort=80<br>org.gradle.jvmargs=-DsocksProxyHost=127.0.0.1 -DsocksProxyPort=1080<br>systemProp.https.proxyHost=mirrors.opencas.cn<br>systemProp.socks.proxyPort=1080<br>systemProp.http.proxyPort=80</p>
<pre><code>
</code></pre>
]]></content>
      <tags>
        <tag>plantUml</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体相机系列:R版本ZoomRatio</title>
    <url>/2021/04/16/2021-04-16-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_R%E7%89%88%E6%9C%ACZoomRatio/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android R版本增加了新的zoomRatio的方式进行变焦调节，可以更精确的进行zoom调节。</p>
<h2 id="fwk适配的时序图"><a href="#fwk适配的时序图" class="headerlink" title="fwk适配的时序图"></a>fwk适配的时序图</h2><span id="more"></span>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/ZoomRatio.png" alt="ZoomRatio时序图"></p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建流媒体服务器</title>
    <url>/2021/05/02/2021-05-02-%E6%90%AD%E5%BB%BA%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这两天在学习流媒体相关的知识，下面是搭建流RTMP媒体服务器的过程。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>linux服务器一台，MP4格式影片一部。</p>
<p>ffmpeg、yasm、lame工具安装部署包。nginx及ngix的rtmp码流插件包</p>
<p>linux的公共组件包pcre-8.44及openssl-1.1.1k。</p>
<span id="more"></span>
<h4 id="工具包准备"><a href="#工具包准备" class="headerlink" title="工具包准备"></a>工具包准备</h4><p><a href="http://www.tortall.net/projects/yasm/releases/">下载yasm-1.3.0.tar.gz</a></p>
<p><a href="https://sourceforge.net/projects/lame/files/lame/3.99/lame-3.99.4.tar.gz/download">下载lame-3.99.4.tar.gz</a></p>
<p><a href="http://ffmpeg.org/download.html#build-linux">下载ffmpeg</a></p>
<p><a href="http://nginx.org/en/download.html">下载nginx</a></p>
<p><a href="https://www.openssl.org/source/">下载openssl-1.1.1k</a></p>
<p><a href="https://github.com/arut/nginx-rtmp-module/archive/master.zip">下载nginx-rtmp-module</a></p>
<p><a href="https://sourceforge.net/projects/pcre/">下载pcre</a></p>
<p>下面是我准备好的安装文件，可以通过上面的链接去下载新版本，或者直接去<a href="https://gitee.com/hangliebe/blog/tree/master/file/RTMP">RTMP</a>下载我使用的相同版本。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619963816999.png" alt="1619963816999"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="解压并安装yasm汇编器"><a href="#解压并安装yasm汇编器" class="headerlink" title="解压并安装yasm汇编器"></a>解压并安装yasm汇编器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvzf yasm-1.3.0.tar.gz //解压</span><br><span class="line">cd yasm-1.3.0 //进入解压目录</span><br><span class="line">./configure //配置安装环境</span><br><span class="line">make </span><br><span class="line">make install </span><br></pre></td></tr></table></figure>

<p>yasm –version 可以查看到安装的结果，说明安装成功。</p>
<h3 id="解压并安装解码器"><a href="#解压并安装解码器" class="headerlink" title="解压并安装解码器"></a>解压并安装解码器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf lame-3.99.4.tar.gz</span><br><span class="line">cd lame-3.99.4</span><br><span class="line">./configure --enable-shared --prefix=/usr</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>配置PATH</p>
<p><code>vi /etc/profile</code><br>在文件末尾输入下面两句:<br>export ENCODER_PATH=/usr<br>export PATH=${ENCODER_PATH}/bin:$PATH</p>
<p><code>source /etc/profile</code></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619964272179.png" alt="1619964272179"></p>
<p>lame –version 可以查看到安装的结果，说明安装成功。</p>
<h3 id="解压并安装ffmpeg"><a href="#解压并安装ffmpeg" class="headerlink" title="解压并安装ffmpeg"></a>解压并安装ffmpeg</h3><p>新建ffmpeg 安装目录/root/apps/ffmpeg4_3(这是我创建的安装目录)，下面–prefix可以对应改正自己创建的安装目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -xvJf ffmpeg-4.3.2.tar.xz</span><br><span class="line">cd ffmpeg-4.3.2</span><br><span class="line"> ./configure --prefix=/root/apps/ffmpeg4_3 --enable-gpl --enable-shared --enable-libmp3lame</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装完成后到安装目录下可以看到bin;include;lib;share四个文件夹：</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619957813779.png" alt="1619957813779"></p>
<p>配置PATH</p>
<p><code>vi /etc/profile</code><br>在文件末尾输入下面两句:<br>export FFMPEG_PATH=/root/apps/ffmpeg4_3<br>export PATH=${FFMPEG_PATH}/bin:$PATH</p>
<p><code>source /etc/profile</code></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619964281618.png" alt="1619964281618"></p>
<p>ffmpeg –version 可以查看到安装的结果，说明安装成功。</p>
<p>但是这个时候很有可能会打印下面的错误：</p>
<p><code>ffmpeg: error while loading shared libraries: libavdevice.so.58: cannot open shared object file: No such file or directory</code></p>
<p>这是因为lib目录没有加载链接到系统库中，系统ld目录列表在/etc/ld.so.config中，这里面引用了/etc/ld.so.conf.d/下面所有的.conf文件。所以我们要在这创建ffmpeg.conf文件,并且写入<code>/root/apps/ffmpeg4_3/lib</code>,然后执行<code>ldconfig</code></p>
<p>再ffmpeg –version 查看版本。</p>
<p>如果进一步出现下面的报错，就在ffmpeg.config中添加<code>/usr/local/lib</code></p>
<p><code>ffmpeg: error while loading shared libraries: libmp3lame.so.0: cannot open shared object file: No such file or directory</code></p>
<h3 id="安装部署Nginx"><a href="#安装部署Nginx" class="headerlink" title="安装部署Nginx"></a>安装部署Nginx</h3><h4 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h4><p>进入nginx的解压路径，进行编译与安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/src/nginx --add-module=../nginx-rtmp-module-master --with-http_ssl_module --with-pcre=../pcre-8.44 --with-openssl=../openssl-1.1.1k</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="进行rtmp模块配置"><a href="#进行rtmp模块配置" class="headerlink" title="进行rtmp模块配置"></a>进行rtmp模块配置</h4><p><code>vi /usr/local/src/nginx/conf/nginx.conf</code> 添加下面trmp模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 1935; #端口号</span><br><span class="line">        chunk_size 4000;</span><br><span class="line">        application hangrtmp &#123; #推流请求路径</span><br><span class="line">            live on; #开启实时</span><br><span class="line">            hls on; #开启hls</span><br><span class="line">            hls_path /usr/local/src/nginx/html/hangrtmp; #推流路径</span><br><span class="line">            hls_fragment 5s; #每个TS文件包含5秒的视频内容</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619963518159.png" alt="1619963518159"></p>
<h4 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/local/src/nginx/sbin</span><br><span class="line">./nginx</span><br><span class="line">lsof -ni:1935</span><br></pre></td></tr></table></figure>

<h3 id="推流测试"><a href="#推流测试" class="headerlink" title="推流测试"></a>推流测试</h3><p>ffmpeg -re -i abc.mp4 -flvflags no_duration_filesize -c copy -f flv rtmp://199.115.229.239:1935/hangrtmp</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619962905747.png" alt="1619962905747"></p>
<p>看到上面的结果说明安装配置成功</p>
<h2 id="VLC进行网络串流播放"><a href="#VLC进行网络串流播放" class="headerlink" title="VLC进行网络串流播放"></a>VLC进行网络串流播放</h2><p>windows下载<a href="https://get.videolan.org/vlc/3.0.12/win32/vlc-3.0.12-win32.exe">vlc-3.0.12</a></p>
<p>媒体-打开网络串流-输入rtmp://199.115.229.239:1935/hangrtmp-播放</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/media/1619963184547.png" alt="1619963184547"></p>
]]></content>
      <tags>
        <tag>流媒体</tag>
      </tags>
  </entry>
  <entry>
    <title>一份推荐书单</title>
    <url>/2021/05/17/2021-05-17-%E4%B8%80%E4%BB%BD%E6%8E%A8%E8%8D%90%E4%B9%A6%E5%8D%95/</url>
    <content><![CDATA[<p>部门主管爽总推荐了一份个人阅读的书单，并建议大家每天阅读30分钟。以下是书单列表，码出来记录下：</p>
<p>《伊斯坦布尔：一座城市的记忆》</p>
<p>《那不勒斯四部曲》费兰特</p>
<p>《一个游荡者的世界》许知远</p>
<span id="more"></span>
<p>《北上》徐泽臣</p>
<p>《世界之用》</p>
<p>《尘埃落地》阿来</p>
<p>《一句顶一万句》刘震云</p>
<p>《本源》丹布朗</p>
<p>《渺小一生》</p>
<p>《万火归一》</p>
<p>《帝国轶闻》费尔南多</p>
<p>《你当像鸟飞往你的山》</p>
<p>《往事与随想》</p>
<p>《云游》托卡尔丘克</p>
<p>《远山淡影》石黑一雄</p>
<p>《荒原狼》赫尔曼</p>
<p>《千只鹤》川端康成</p>
<p>《三体》</p>
<p>《去吧，摩西》</p>
<p>《中央帝国的哲学密码》</p>
<p>《象牙塔的变迁》</p>
<p>《变革中国》</p>
<p>《溢出》施展</p>
<p>《艾希曼在耶路撒冷》</p>
<p>《美国式婚姻》</p>
<p>《人类的未来》</p>
<p>《红色资本》</p>
<p>《十年轮回》沈联涛</p>
<p>《暗淡蓝点：探寻人类的太空家园》卡尔萨根</p>
<p>《大图景》肖恩卡罗尔</p>
<p>《百岁人生：长寿时代的生活和工作》</p>
<p>《生命与新物理学》保罗戴维斯</p>
<p>《贪婪大脑》</p>
<p>《生命的跃升》</p>
<p>《用数据思考，避免情绪化决策》</p>
<p>《时间的秩序》</p>
<p>《集装箱改变世界》</p>
<p>《反脆弱：从不确定性中获益》</p>
<p>《舆论》</p>
<p>《硅谷钢铁侠》阿什利万斯</p>
<p>《信仰－孙正义传》</p>
<p>《莫迪传》</p>
<p>《邓小平时代》傅高义</p>
<p>《香农传－从0到1》</p>
<p>《商界裸奔》</p>
<p>《黑石的起点，我的顶点》</p>
<p>《史蒂夫乔布斯传》</p>
<p>《曾国藩传》</p>
<p>《拿破仑》</p>
<p>《成为》米歇尔奥巴马</p>
<p>《褚时健传》</p>
<p>《必然》凯文凯利</p>
<p>《时运变迁》</p>
<p>《商业模式全史》</p>
<p>《驾驭情绪的力量》</p>
<p>《最小阻力之路》</p>
<p>《财政关系与地方政府行为》</p>
<p>《周期：投资计划，风险，态度与市场周期》</p>
<p>《大而不倒》</p>
<p>《峭壁边缘》</p>
<p>《发现利润区》</p>
<p>《贝佐斯与亚马逊时代》</p>
<p>《转向：用工程师思维解决商业难题》</p>
<p>《HBO的战略内容》</p>
<p>《游戏化思维：改变未来商业的新力量》</p>
<p>《创业维艰》</p>
<p>《下一站火星：马斯克和贝佐斯的太空争夺战》</p>
<p>《重新定义公司》</p>
<p>《决战元素周期表》</p>
<p>《打开一颗心：外科医生的生死故事》</p>
<p>《跨越鸿沟》</p>
<p>《改变心理学的40项研究》</p>
<p>《心理学与生活》</p>
<p>《乌合之众》</p>
<p>《正念》</p>
<p>《少有人走的路》</p>
<p>《进化心理学》</p>
<p>《社会性动物》</p>
<p>《失控》</p>
<p>《哥德尔 艾舍尔 巴赫》</p>
<p>《人格心理学》</p>
<p>《发展心理学：人的毕生发展》</p>
<p>《为何家会伤人》</p>
]]></content>
      <tags>
        <tag>书单</tag>
      </tags>
  </entry>
  <entry>
    <title>关键网址大全</title>
    <url>/2021/05/19/2021-05-19-%E5%85%B3%E9%94%AE%E7%BD%91%E5%9D%80%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="专利检索网址"><a href="#专利检索网址" class="headerlink" title="专利检索网址"></a>专利检索网址</h2><ul>
<li><a href="www.freepatentonline.com/search.html">freepatentonline</a></li>
<li><a href="www.wipeglobal.com">wipegloba</a></li>
</ul>
]]></content>
      <tags>
        <tag>关键网址</tag>
      </tags>
  </entry>
  <entry>
    <title>闪光灯</title>
    <url>/2021/05/19/2021-05-19-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E9%97%AA%E5%85%89%E7%81%AF/</url>
    <content><![CDATA[<h2 id="手机闪光灯"><a href="#手机闪光灯" class="headerlink" title="手机闪光灯"></a>手机闪光灯</h2><p>闪光灯是拍摄时的人造光源，可以对场景补光，按下相机快门后，通常在1ms到5ms秒之间，照亮场景。闪光灯是智能手机的标配. </p>
<p>手机上闪光灯一般多用LED闪光灯，高端旗舰机上更多使用双色LED（Dual LED）闪光灯技术，单反相机则更多使用Xenon灯。</p>
<p>在手机中，闪光灯的控制主体为ae的算法，闪光灯的流程分为预闪和强闪。在环境较暗时，ae控制预闪来计算曝光3A等信息，用于控制拍摄时控制sensor曝光和闪光灯的一个打闪时间，预闪可以由flash驱动直接控制，强闪则由flash control（isp内部模块）通过GPIO的电频时间来控制闪光灯的打闪时间。</p>
<span id="more"></span>
<h2 id="手电筒"><a href="#手电筒" class="headerlink" title="手电筒"></a>手电筒</h2><p>通过CameraManager可以直接打开闪光灯。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CameraManager.setTorchMode(&quot;0&quot;, true); // 打开</span><br><span class="line">CameraManager.setTorchMode(&quot;0&quot;, false); // 关闭</span><br></pre></td></tr></table></figure>

<h2 id="拍照闪光灯"><a href="#拍照闪光灯" class="headerlink" title="拍照闪光灯"></a>拍照闪光灯</h2><p>通过在请求里控制下面两个请求参数来控制闪光灯：</p>
<p>CaptureRequest.CONTROL_AE_MODE</p>
<p>CaptureRequest.FLASH_MODE</p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>智能手机销量统计</title>
    <url>/2021/05/29/2021-05-29-%E6%99%BA%E8%83%BD%E6%89%8B%E6%9C%BA%E9%94%80%E9%87%8F%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="智能手机"><a href="#智能手机" class="headerlink" title="智能手机"></a>智能手机</h2><p>整理了近年来的手机销量情况，数据如下：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>数据发布机构</th>
<th>年份</th>
<th>智能手机（亿）</th>
<th>全部手机（亿）</th>
<th>苹果（亿）</th>
<th>三星（亿）</th>
<th>华为（亿）</th>
<th>小米（亿）</th>
<th>oppo（亿）</th>
<th>vivo（亿）</th>
<th>中兴（亿）</th>
<th>诺基亚（亿）</th>
<th>LG（亿）</th>
<th>TCL（亿）</th>
<th>联想（亿）</th>
</tr>
</thead>
<tbody><tr>
<td>Gartner</td>
<td>2011</td>
<td>4.72</td>
<td>17.757</td>
<td>0.8926</td>
<td>3.14</td>
<td>0.4066</td>
<td></td>
<td></td>
<td></td>
<td>0.5688</td>
<td>4.22</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Gartner</td>
<td>2012</td>
<td>7.25</td>
<td>17.46</td>
<td>1.3</td>
<td>3.846</td>
<td>0.47288</td>
<td></td>
<td></td>
<td></td>
<td>0.6734</td>
<td>3.33</td>
<td>0.58</td>
<td>0.37</td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2013</td>
<td>10.04</td>
<td>18.21</td>
<td>1.53</td>
<td>3.13</td>
<td>0.488</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.477</td>
<td></td>
<td></td>
</tr>
<tr>
<td>TrendForce</td>
<td>2014</td>
<td>11.67</td>
<td></td>
<td>1.913</td>
<td>3.264</td>
<td>0.7</td>
<td>0.6</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.7</td>
<td></td>
<td>0.9</td>
</tr>
<tr>
<td>IDC</td>
<td>2015</td>
<td>14.3</td>
<td></td>
<td>2.31</td>
<td>3.248</td>
<td>1.06</td>
<td>0.708</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0.74</td>
</tr>
<tr>
<td>IDC</td>
<td>2016</td>
<td>14.7</td>
<td></td>
<td>2.15</td>
<td>3.11</td>
<td>1.39</td>
<td></td>
<td>0.99</td>
<td>0.77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2017</td>
<td>14.72</td>
<td></td>
<td>2.158</td>
<td>3.177</td>
<td>1.542</td>
<td>0.92</td>
<td>1.117</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2018</td>
<td>14.026</td>
<td></td>
<td>2.088</td>
<td>2.923</td>
<td>2.06</td>
<td>1.226</td>
<td>1.131</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2019</td>
<td>13.71</td>
<td></td>
<td>1.91</td>
<td>2.957</td>
<td>2.406</td>
<td>1.256</td>
<td>1.143</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2020</td>
<td>12.92</td>
<td></td>
<td>2.061</td>
<td>2.667</td>
<td>1.89（中国市场1.249）</td>
<td>1.478</td>
<td></td>
<td>1.117</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>IDC</td>
<td>2021Q1</td>
<td>3.455</td>
<td></td>
<td>0.552</td>
<td>0.753</td>
<td></td>
<td>0.486</td>
<td>0.375</td>
<td>0.349</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622300809827.png" alt="1622300809827"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622301041648.png" alt="1622301041648"></p>
<p>2020年受美国多重打压，华为终端业务受重挫，销量数据大滑，没能实现销量超越三星的成为世界第一的目标。2020年1.89亿销量中国内市场有1.249亿，如果不是国内保有了较好的销售量，数据会更惨。</p>
<h2 id="穿戴设备"><a href="#穿戴设备" class="headerlink" title="穿戴设备"></a>穿戴设备</h2><p>近年来穿戴设备销售情况，数据来源于IDC</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622815872742.png" alt="1622815872742"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622816030476.png" alt="1622816030476"></p>
]]></content>
      <tags>
        <tag>销量</tag>
      </tags>
  </entry>
  <entry>
    <title>CMOS介绍</title>
    <url>/2021/05/30/2021-05-30-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_CMOS/</url>
    <content><![CDATA[<p>摄像头主要环节：镜头组，音圈马达，红外滤光片，CIS图像传感器，模组等。其中CIS图像传感器在摄像头产业链中价值量高达52%，现在CMOS传感器市场占有率已经远超CCD。</p>
<h2 id="CMOS传感器行业竞争格局"><a href="#CMOS传感器行业竞争格局" class="headerlink" title="CMOS传感器行业竞争格局"></a>CMOS传感器行业竞争格局</h2><span id="more"></span>

<hr>
<p>第一梯队：</p>
<p>索尼，引领行业技术发展<br>全球市场占有率几乎50%</p>
<hr>
<p>第二梯队<br>豪威科技，三星，佳能</p>
<hr>
<p>第三梯队<br>格科微，思特威</p>
<hr>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1623853141232.png" alt="1623851745331"></p>
<h3 id="豪威科技"><a href="#豪威科技" class="headerlink" title="豪威科技"></a>豪威科技</h3><p> omnivision简称OV，中文名豪威科技，是一家成立于1995 的美商半导体公司， 专业开发高度集成CMOS影像技术。 </p>
<p> 从2016年私有化开始，到2018年8月15日被韦尔股份收购，豪威科技在过去几年曾经多次被多家公司提出收购，最终被韦尔股份收入囊下。</p>
<p>豪威科技公司在中国布局有两个研发中心：坐落于上海张江高科技园区内的豪威科技（上海）有限公司和位于有光谷之称的武汉东湖高新技术开发区的豪威科技（武汉）有限公司。前者主要致力于CMOS摄像芯片设计、应用开发的工程技术及市场拓展；后者则侧重于软件开发、系统集成、以及图像、流媒体应用和提高的研究，同时从事大型图像集成、流媒体的分享、计算、有关云存储处理、云计算和云运用等开发。 此外，豪威科技还在上海松江出口加工区设立了技术装备均为先进的加工检测中心豪威半导体（上海）有限责任公司，以及微型镜头及感应芯片的模组研发生产中心豪威光电子科技（上海）有限公司。 </p>
<h2 id="图像传感器发展历程"><a href="#图像传感器发展历程" class="headerlink" title="图像传感器发展历程"></a>图像传感器发展历程</h2><table>
<thead>
<tr>
<th>年代</th>
<th>图像传感器</th>
</tr>
</thead>
<tbody><tr>
<td>20世纪50年代</td>
<td>光学倍增管（PMT）</td>
</tr>
<tr>
<td>1965-1970</td>
<td>光电及双极管阵列</td>
</tr>
<tr>
<td>1970年后</td>
<td>CCD图像传感器</td>
</tr>
<tr>
<td>90年代末</td>
<td>CMOS图像传感器</td>
</tr>
</tbody></table>
<h2 id="图像传感器市场占比"><a href="#图像传感器市场占比" class="headerlink" title="图像传感器市场占比"></a>图像传感器市场占比</h2><p>以下图表为IC Insights前瞻产业研究院统计的图像传感器销售额占比数据。<br><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622385067738.png" alt="1622385067738"></p>
<h2 id="相关学习材料"><a href="#相关学习材料" class="headerlink" title="相关学习材料"></a>相关学习材料</h2><p><a href="http://pdf.dfcfw.com/pdf/H3_AP202009251417285625_1.pdf">http://pdf.dfcfw.com/pdf/H3_AP202009251417285625_1.pdf</a></p>
]]></content>
      <tags>
        <tag>图像传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>汽车销量</title>
    <url>/2021/05/30/2021-05-30-%E6%B1%BD%E8%BD%A6%E9%94%80%E9%87%8F%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="销量统计"><a href="#销量统计" class="headerlink" title="销量统计"></a>销量统计</h2><p>统计的近年的汽车销售数据，国内数据来源中国汽车工业协会，国际数据来源于（？？忘掉了）</p>
<span id="more"></span>

<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622386095101.png" alt="中国汽车历年销量"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1622386596874.png" alt="中国新能源汽车销量"></p>
<p>全球汽车销量情况：</p>
<p>年份    全球合计<br>2020    7797.12万<br>2019    9042.37万</p>
<h2 id="2035规划"><a href="#2035规划" class="headerlink" title="2035规划"></a>2035规划</h2><p> 11月2日，国务院办公厅正式发布了《<a href="https://baike.baidu.com/item/%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E4%BA%A7%E4%B8%9A%E5%8F%91%E5%B1%95%E8%A7%84%E5%88%92%EF%BC%882021-2035%E5%B9%B4%EF%BC%89/23699593?fr=aladdin">新能源汽车产业发展规划（2021-2035年）</a>》 ，规划在发展愿景中指出， 纯电动乘用车新车平均电耗降至12.0千瓦时/百公里，新能源汽车新车销售量达到汽车新车销售总量的20%左右 。如果以国内3000万市场算的话，2025年新能源汽车预计可以到 600万销售量。</p>
]]></content>
      <tags>
        <tag>汽车</tag>
      </tags>
  </entry>
  <entry>
    <title>关于工作的一些思考</title>
    <url>/2021/06/06/2021-06-06-%E5%85%B3%E4%BA%8E%E5%B7%A5%E4%BD%9C%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>2019年6月24号入职至今也快有两年了，一路匆匆忙忙，有所成长，也有遗憾。这里记录下一些最近关于工作生活的想法。</p>
<span id="more"></span>

<h2 id="认准自己的方向"><a href="#认准自己的方向" class="headerlink" title="认准自己的方向"></a>认准自己的方向</h2><p>年轻人大多数是不太满意自己的工作的。</p>
<p>毕业以来，我和同行业以及不同行业的朋友多次做过关于工作的交流，发现多数同学并不满意自己的工作。工作的内容没有意义，所做的业务没有前景，加班多，工资没有某某行业的高是最常见的抱怨。当然，我也常常羡慕有的同学一天八小时的工作，羡慕互联网行业普通岗位就能拿到高薪。但是，别人的生活终究是别人的，如何在这个信息和人才快速更迭的时代持续保持竞争力，如何持续对工作岗位作出贡献和吸收新的能量，如何熟悉一个领域并快速成为领域人才，如何在诸多外场干扰因素下不迷失方向，这些问题才是我个人应该关注的。</p>
<p>每个人都要认准自己的方向，心无旁骛。最近北大韦神“韦东奕”的采访视频很火，可以看出韦神是一个心思纯粹的人，他一定是热爱数学，并且愿意为之付出百分百努力的人。当我们认准自己的方向以后，潜心学习，努力工作，也一定能有所成就。</p>
<h2 id="兴趣始于成就感"><a href="#兴趣始于成就感" class="headerlink" title="兴趣始于成就感"></a>兴趣始于成就感</h2><p>就像一个小孩打篮球，因为一开始玩的比别人好就很容易激发他对篮球运动的热情，从而更加倍的投入练习，从此一切都变成了兴趣和自信自强的正向驱动。</p>
<p>工作的负面情绪常常来源于很多同学认为自己的工作没有意义，其根本原因我认为是大家觉得自己的业务可替代性太强，这种危机感可以使有益的，但是不加以调整就容易让自己生活陷入内耗。之前部门主管和一二年级新员工交流时问到我一个问题，什么情况下工作是最累的。我的回答是工作内容和个人兴趣不在一个方向上的时候。通过这次交流，我对内耗做了一次思考。</p>
<p><strong>内耗效应这个词来源于物理学，指的是机器或其他装置本身所消耗的、没有对外做功的能量，内耗效应也就是内部资源不协调带来的负效应。</strong>内耗常常成为一个人进步的最大阻力，员工在怀疑工作领域时，很难找到在该领域前进的方向。我在做多媒体相机业务时，常想过相机的代码成熟，修改特性代码量往往不大，在这个责任田里还怎么能获取更多知识，别的责任田好像可以学得更多，在市场上更有竞争力，长久的耕耘在自己这个田里，个人的发展必然会越来越局限，那我是不是应该要换个方向。人一旦陷入这种思维困境，就常常悲观，止步不前。</p>
<p>静下心来想想，自己的所做的领域真的那么不堪吗？其实不见得，一山望着一山高，不过是他乡月圆的假象。我们不应该把自己局限在繁重业务里了，而是要善于发现所从事工作领域的闪光点，那些我们还不懂的知识，去总结学习，慢慢变成一个懂的更多的人。就像相机领域，我会问自己，除了完成一些需求，分析过几个问题，我是不是去挖掘过更多的相机甚至其相关领域的知识。比如：相机是属于多媒体领域，我是否熟知多媒体音视频的知识？相机的硬件和软件结构是否熟知？相机业务主要的图像处理算法都有哪些……其他的领域也是如此，我相信大多数领域其实是有很多东西可以学习。当一个人学习了解了更多，会更有成就感，而兴趣是始于成就感。</p>
<h2 id="螺丝钉和U盘"><a href="#螺丝钉和U盘" class="headerlink" title="螺丝钉和U盘"></a>螺丝钉和U盘</h2><p>机械时代当螺丝钉，信息时代做U盘。</p>
<p>螺丝钉是不注重自身的差异性的，及易被替代，在生锈时候很自然的被抛弃。</p>
<p>U盘是不一样的，每个设备里存储着不一样的文件。工作要把自己当成U盘，而不是螺丝钉，要尽可能的学习知识，总结工作经验形成自己的知识体系。这样即使有一天离开了一个工作平台，我们也可以接入另一个平台的接口。</p>
<p> 哈佛大学有两个经济学家在《教育与技术的赛跑》书里提出观点说:技术发展永远超越教育，教育在技术发展之后要做的第一件事，是重新定义什么叫有价值的能力。在工作过程中要识别有用知识，存储到自己的知识库中，提升自身有价值的能力。</p>
<h2 id="多样性优于能力"><a href="#多样性优于能力" class="headerlink" title="多样性优于能力"></a>多样性优于能力</h2><p>《差异：多元化如何仿造出更好的组织、公司、学校和社会》一书的作者斯科特·佩奇说：”能力很重要，但其边际效应会递减。“ 边际效应递减也就是说当增加的投入超过某一水平时，新增的每一个单位的投入换来的产出量会下降。这让我们必须思考如何分配知识资本，构建个人知识体系才能让自己变得更有价值？</p>
<p>社会在不断发展，不同学科之间相互渗透，单领域知识往往难以解决复杂的系统问题。就像一个好的MES系统工程师，必须熟悉产品结构，生产工艺，物流管理等等，必须对上了解ERP系统，对下了解PLC控制，除此之外还要会编程。所以解决复杂问题就要求工程师必须具备多样性的知识。《爆裂》一书列出了未来社会的9大生存原则，其中就指出多样性优于能力。</p>
<p>2021年1月，国务院学位委员会、教育部新设置“交叉学科”门类，成为了中国第14个学科门类。说明未来多样性的交叉学科是一个趋势了。如果工作的业务总是单一重复，那说明我们要开始主动学习，打破业务的壁垒，寻求多样性。</p>
<h2 id="构建知识体系"><a href="#构建知识体系" class="headerlink" title="构建知识体系"></a>构建知识体系</h2><p>一个人的经历如果不善于总结，形成自己的知识体系，凝结成智慧，那我们的经历不过是虚度光影，难以变为经验。</p>
<p>个人知识体系不同于知识本身的体系，它应该结合个人的特长，行业，岗位和兴趣。每个人在工作生活中构建出来的知识体系都是不一样的，即使是在相同的职业。</p>
<p> DIKW体系是一个关于数据、信息、知识及智慧的模型。 这个提供了一种构建个人知识体系的模型，实际上知识和智慧就是来源于原始数据，只要有心，就可以从数据中提取信息，变成自己的知识和智慧。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/DIKW.jpg" alt="DIKW模型"></p>
<p>另外构建个人知识体系要持续保持好的思考习惯，做到独立思考和主动思考。独立思考做到不随波逐流，人云亦云，遇到事情有自己的判断力。主动思考要做到能主动提出问题，并寻找答案。</p>
]]></content>
      <tags>
        <tag>个人思考</tag>
      </tags>
  </entry>
  <entry>
    <title>端午节小记</title>
    <url>/2021/06/14/2021-06-14-%E7%AB%AF%E5%8D%88%E8%8A%82%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>哥哥嫂子，小侄女，还有妈妈端午节来上海玩了。</p>
<h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><p>6月12号，放假第一天，我们一早开车去了市里，第一站直奔上海科技馆。</p>
<span id="more"></span>

<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/kejiguan2.jpg" alt="kejiguan2"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/kejiguan1.jpg" alt="kejiguan1"></p>
<p>从科技馆出来，去了就近的一家湖南菜饭店，叫温暖你的猪，饱餐了一顿。饭后接着开车去往城隍庙，在城隍庙停车场停车以后，没逛多久，发生一个小插曲，琴吖说手机找不到了。我打了个电话给饭店，想让店员帮忙去卫生间找找手机，和店员沟通后发现手机已经被人拾到并放到保安室了，随后我和哥开车去取手机，她们娘仨继续逛街。一来一回，一个来小时。</p>
<p>回来后，发现嫂子和小侄女穿上了漂亮的汉服装。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/chenghuangmiao.jpg" alt="chenghuangmiao"></p>
<p>接着我们一路步行前往外滩，在外滩拍照留念。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/hepingfandian.jpg" alt="hepingfandian"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund9.jpg" alt="thebund9"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund8.jpg" alt="thebund8"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund4.jpg" alt="thebund4"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund5.jpg" alt="thebund5"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund6.jpg" alt="thebund6"></p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/thebund7.jpg" alt="thebund7"></p>
<p>这一天下来已经超级累了，她们娘仨打了个车去停车场，我和哥骑着哈罗单车赶去。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/road1.jpg" alt="road1"></p>
<p>一路奔回松江后，去了追月小酒肆吃晚饭。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/life/dinner.jpg" alt="dinner"></p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>第二天下雨，我们原本要去泰晤士小镇逛逛的计划取消了。上午去买了点衣服，下午就在家休息，晚上我们一起在家看了电影《你好，李焕英》。</p>
<p>今天一早7点40的高铁，我将家人们送到松江南站。</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻引擎入门</title>
    <url>/2021/06/19/2021-06-19-%E8%99%9A%E5%B9%BB%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/unrealengine.jpeg" alt="虚幻引擎"></p>
<h2 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h2><p>直接在官网注册下载和安装。</p>
<h2 id="常用按钮"><a href="#常用按钮" class="headerlink" title="常用按钮"></a>常用按钮</h2><p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1624018855285.png" alt="1624018855285"></p>
<span id="more"></span>
<p>上图中</p>
<p>123对应移动旋转和缩放。</p>
<p>4坐标系</p>
<p>56网络捕捉</p>
<p>7旋转捕捉</p>
<p>8比例捕捉</p>
<p>9摄像机速度</p>
<p>再右边是最大化视口</p>
<h3 id="鼠标操作"><a href="#鼠标操作" class="headerlink" title="鼠标操作"></a>鼠标操作</h3><p>鼠标左键拖动可以前后移动和左右旋转显示位置。</p>
<p>鼠标右键拖动可以旋转视口相机。</p>
<p>鼠标左键+右键+拖动可以上下左右拖动。</p>
<h3 id="鼠标-键盘操作"><a href="#鼠标-键盘操作" class="headerlink" title="鼠标+键盘操作"></a>鼠标+键盘操作</h3><p>F键：将相机聚焦到选中的对象上。</p>
<p>按住左键或者右键后，可用字母控制相机：</p>
<p>WSAD：和玩游戏一样，前后左右移动相机。</p>
<p>EQ：上下移动相机。</p>
<p>ZC：推进和拉远相机（比较常用）</p>
<p>当使用右键+字母方式移动时候，可以通过鼠标滚轮来控制速度。</p>
<h3 id="Alt操作"><a href="#Alt操作" class="headerlink" title="Alt操作"></a>Alt操作</h3><p>Alt+鼠标左键+拖拽：围绕一个单独的支点翻转</p>
<p>Alt+鼠标右键+拖拽：向前推动相机接近或者远离支点。</p>
<p>Alt+鼠标中键+拖拽：根据鼠标移动方向控制相机左右上下移动。</p>
<h2 id="编辑器视口"><a href="#编辑器视口" class="headerlink" title="编辑器视口"></a>编辑器视口</h2><p>通过按Alt和G、H、J、K可以循环查看视口的类型，分别对应透视、正面、侧面和顶部。</p>
<h2 id="其他快捷操作"><a href="#其他快捷操作" class="headerlink" title="其他快捷操作"></a>其他快捷操作</h2><p>Alt+P：进入Play模式</p>
<p>ESC：退出预览模式</p>
<p>F11：进入仿真模式</p>
<p>F8：弹出</p>
<p>F:快速聚焦</p>
<p>Alt+拖拽：原样复制</p>
<p>Shift+拖拽：沿着轴向移动</p>
<p>Ctrl+G:打组</p>
<p>Shift+G:解组</p>
<p>Ctrl+W:直接复制</p>
<p>H：隐藏物体</p>
<p>End:直接让物体附着到地面</p>
<p><strong>快速对齐</strong>：两步操作，1 alt+v+按住鼠标滚轮中键 移动物体轴点中心 2 v+移动</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/duiqi.gif" alt="物体表面对齐"></p>
<h2 id="蓝图"><a href="#蓝图" class="headerlink" title="蓝图"></a>蓝图</h2><p>虚幻引擎中蓝图-可视化脚本系统是一个完整的游戏脚本系统。<br>关卡蓝图（Level Blueprint）是作用于整个关卡的全局事件图标，每个关卡都会有一个Level Blueprint ，我们可以在编辑器中编辑该蓝图但是不能通过编辑器创建新的关卡蓝图。</p>
<p>蓝图类型有：关卡蓝图，蓝图类，蓝图宏库和蓝图接口。</p>
]]></content>
      <tags>
        <tag>计算机图形学</tag>
        <tag>虚幻引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>从简看相机框架</title>
    <url>/2021/06/24/2021-06-24-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E4%BB%8E%E7%AE%80%E7%9C%8B%E7%9B%B8%E6%9C%BA%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>安卓相机框架代码量很大，11版本统计大概有300多个文件，85k代码，但其结构其实是很清晰的。</p>
<blockquote>
<p><strong>基于Linux cloc 工具统计：</strong></p>
<p>frameworks/av/services/camera/libcameraservice</p>
<p>文件数量134,代码量45287</p>
<p>frameworks/av/camera</p>
<p>文件数75 代码量16208</p>
</blockquote>
<span id="more"></span>
<blockquote>
<p>frameworks/base/core/java/android/hardware/camera2</p>
<p>文件数117，代码量23319</p>
</blockquote>
<p>相机框架架构<strong>纵向看</strong>分为两层：</p>
<p><strong>Framework API层</strong>：给应用提供一套java的 API接口操作相机，通过AIDL接口跨进程调用服务层。</p>
<p><strong>CameraServer 服务层</strong>：是相机框架提供相机管理控制的服务，作为系统的常驻服务进程。其再下层就是HAL层。</p>
<p><strong>横向看</strong>主要包含两条线：</p>
<p><strong>CameraService</strong>：负责相机设备管理，包括查询，打开，关闭，状态监听。在API层提供CmaeraManger服务管理类，在native层由CameraService统一控制。</p>
<p><strong>CameraDevice</strong>：负责具体设备控制，包括会话管理，buffer循环。对应用层测提供CameraDevice创建会话和下发请求等操作，对应到native层Camera3Device， 负责buffer循环控制（请求下发和接受回帧）。</p>
<p>下面是<a href="https://source.android.google.cn/devices/camera">官方</a>提供的框架图</p>
<p><img src="https://source.android.google.cn/devices/camera/images/ape_fwk_camera2.png" alt="相机框架图"></p>
]]></content>
      <tags>
        <tag>多媒体相机</tag>
        <tag>相机框架</tag>
      </tags>
  </entry>
  <entry>
    <title>音频基础</title>
    <url>/2021/06/25/2021-06-25-%E5%A4%9A%E5%AA%92%E4%BD%93%E9%9F%B3%E8%A7%86%E9%A2%91%E7%B3%BB%E5%88%97_%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>音频信号是一种连续变化的模拟信号，在计算机中通过模/数转换器（A/D）将音频模拟信号转换成二进制数字信号。</p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p>A/D转换器每秒上万次速率对声波进行采样，每一秒采样样本的数目称为采样频率。</p>
<p>正常人听觉的频率范围大约在20HZ~20kHZ,根据奈奎斯采样理论，为了保证声音不失真，采样频率应该在40kHZ左右。一般来说，采样频率大于48kHZ可以称为高清音频。</p>
<p>通常把音频采样过程叫脉冲编码调制编码（PCM编码），采样值也叫PCM值。</p>
<h2 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h2><span id="more"></span>
<p>把采样得到的声音信号幅度转换为数字值。可以分为均匀量化和非均匀量化。<br>时间上离散叫采样，幅度上离散叫量化。<br>（抽空画个图，加个图例）</p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>编码和量化通常在一起完成的，编码就是将模拟信号转换为01数字信号。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1624763992212.png" alt="1624763992212"></p>
<p><code>AMP（Audio MPEG Player）</code></p>
<p>音频采集有专门的codec芯片，做AD转换，通过总线把转换后的数字信号送给CPU处理，播放时候CPU把数字信号送回给codec芯片做DA转换再播放出来。</p>
<h2 id="无损压缩和有损压缩"><a href="#无损压缩和有损压缩" class="headerlink" title="无损压缩和有损压缩"></a>无损压缩和有损压缩</h2><p>其实就是看PCM数据压缩后是否有损伤。</p>
<h2 id="音频处理"><a href="#音频处理" class="headerlink" title="音频处理"></a>音频处理</h2><p>音频处理也就是对PCM数据进行处理，分为前处理和后处理。<br>对音频编码前的PCM数据进行处理叫音频前处理，主要用于语音中，去除干扰，使声音更清晰，主要有处理：回音消除，噪声抑制，增益抑制。</p>
<blockquote>
<p>拓展说明：音频和相机都有3A算法</p>
<p>语音降噪算法三个重要模块：AGC 自动增益控制、AEC 自动回声消除、ANR 自动噪声抑制</p>
<p>相机3A算法: AWB 自动白平衡、AE 自动曝光、AF 自动对焦</p>
</blockquote>
<p>对音频编码后的PCM数据进行处理叫音频后处理，主要用于音乐中，来产生各种音效，使音乐动听，主要有均衡器，混响等。</p>
<h2 id="音频芯片"><a href="#音频芯片" class="headerlink" title="音频芯片"></a>音频芯片</h2><p>codec是“Coder/Decoder”的缩写，codec芯片负责数字与模拟信号的转换。它可将电脑里的数字信号转变成模拟声音信号输出,或者是将外界输入的模拟声音信号转换成数字信号。 </p>
<p>不过codec只是音频芯片的一个分支。音频芯片大家族还包括有ADC编码芯片，Codec编解码芯片，DSP数字处理芯片，运放芯片，功放芯片，音量调节芯片，音频接口芯片，每个分类下面又有不同的品牌。 </p>
<p><a href="http://bbs.hifi168.com/bbs/showtopic-253151.aspx">相关材料</a></p>
<p>目前国际上ADC/DAC市场份额分别被ADI、TI、MAXIM、MICROCHIP等国外企业独占，其中，ADI市占率约为58%，TI占比约为25%，MAXIM占7%，MICROCHIP占3%，难觅国内企业身影。</p>
<p><a href="http://www.yshang.cn/News/IndustryNews/409.html">相关材料</a></p>
]]></content>
      <tags>
        <tag>多媒体音频</tag>
      </tags>
  </entry>
  <entry>
    <title>白平衡</title>
    <url>/2021/07/10/2021-07-10-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_%E7%99%BD%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<h2 id="白平衡"><a href="#白平衡" class="headerlink" title="白平衡"></a>白平衡</h2><p>白平衡（WB）是去除不真实的色差的过程，白平衡的目的就是为了让白色的物体在照片中呈现为白色。</p>
<p>许多人在使用数码摄像机拍摄的时候都会遇到这样的问题：在日光灯的房间里拍摄的影像会显得发绿，在室内钨丝灯光下拍摄出来的景物就会偏黄，而在日光阴影处拍摄到的照片则莫名其妙地偏蓝，其原因就在于白平衡的设置上 </p>
<p>白平衡的英文为White Balance，其基本概念是“不管在任何光源下，都能将白色物体还原为白色”，对在特定光源下拍摄时出现的偏色现象，通过加强对应的补色来进行补偿。相机的白平衡设定可以校准色温的偏差，在拍摄时我们可以大胆地调整白平衡来达到想要的画面效果 。</p>
<h2 id="色温"><a href="#色温" class="headerlink" title="色温"></a>色温</h2><p>色温可以用来描述场景的光源信息。<br>定义：光源发光的颜色与绝对黑体在某一温度下辐射光色相同时，将黑体的温度称为该光源的色温。</p>
<span id="more"></span>
<p>白平衡算法的核心是判断图像的色温。</p>
<p><a href="https://v.qq.com/x/page/k0835kfmzm7.html">视频</a>中的实验可以看到黑体颜色随温度的变化。</p>
<p> <strong>简易色温表</strong></p>
<table>
<thead>
<tr>
<th>光源</th>
<th>色温</th>
<th>光源</th>
<th>色温</th>
</tr>
</thead>
<tbody><tr>
<td>蜡烛及火光</td>
<td>1900K以下</td>
<td>朝阳及夕阳</td>
<td>2000K</td>
</tr>
<tr>
<td>家用钨丝灯</td>
<td>2900K</td>
<td>日出后一小时阳光</td>
<td>3500K</td>
</tr>
<tr>
<td>摄影用钨丝灯</td>
<td>3200K</td>
<td>早晨及午后阳光</td>
<td>4300K</td>
</tr>
<tr>
<td>摄影用石英灯</td>
<td>3200K</td>
<td>平常白昼</td>
<td>5000~6000K</td>
</tr>
<tr>
<td>220Ｖ日光灯</td>
<td>3500~4000K</td>
<td>晴天中午太阳</td>
<td>5400K</td>
</tr>
<tr>
<td>普通日光灯</td>
<td>4500~6000K</td>
<td>阴天</td>
<td>6000K以上</td>
</tr>
<tr>
<td>HMI灯</td>
<td>5600K</td>
<td>晴天时的阴影下</td>
<td>6000~7000K</td>
</tr>
<tr>
<td>水银灯</td>
<td>5800K</td>
<td>雪地</td>
<td>7000~8500K</td>
</tr>
<tr>
<td>电视萤光幕</td>
<td>5500~8000K</td>
<td>蓝天无云的天空</td>
<td>10000K以上</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/Color_temperature_and_color_shift.jpg" alt="色温与色调图"></p>
<h2 id="冷暖色调与色温"><a href="#冷暖色调与色温" class="headerlink" title="冷暖色调与色温"></a>冷暖色调与色温</h2><p>色调与色温的关系容易搞错，实际上<strong>低色温代表暖色调</strong>，一般来说我们会把<strong>黄色、红色、橙色</strong>等颜色归为<strong>暖色调</strong>；而<strong>高色温代表冷色调</strong>，把<strong>白色、蓝色和青色</strong>等颜色归为<strong>冷色调</strong>。 </p>
<h2 id="相机色温设置"><a href="#相机色温设置" class="headerlink" title="相机色温设置"></a>相机色温设置</h2><p>相机设置色温是一般代表设置环境色温。</p>
<p>相机设置的色温正好是光源色温，这时候物体拍摄出来接近真实色彩。</p>
<p><strong>设置高色温：</strong>相机设置的色温高于光源色温，相机认为此时环境是高色温，高色温偏蓝，设备会填补红色以平衡，所以<strong>拍摄出来的照片偏红</strong>。</p>
<p><strong>设置低色温：</strong>相机设置的色温低于光源色温，相机认为此时环境是低色温，低色温偏红，设备会填补蓝色以平衡，所以<strong>拍摄出来的照片偏蓝</strong>。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/color_temperature_setting.jpg" alt="色温设置"></p>
<h2 id="主流白平衡处理流程"><a href="#主流白平衡处理流程" class="headerlink" title="主流白平衡处理流程"></a>主流白平衡处理流程</h2><ul>
<li>标定</li>
<li>统计 多种统计方式<br>关于白色像素统计，设置一个颜色范围，只要在范围内的就可以认为是白色像素，如果块中白色像素太少，可以抛弃掉。<br>如果白色像素太多，很可能因为区域过曝了，也要抛弃掉。</li>
<li>校正</li>
</ul>
<h2 id="传统算法"><a href="#传统算法" class="headerlink" title="传统算法"></a>传统算法</h2><h3 id="灰度世界法"><a href="#灰度世界法" class="headerlink" title="灰度世界法"></a>灰度世界法</h3><p>不需要找到白点，计算过程简单</p>
<h3 id="完美反射法"><a href="#完美反射法" class="headerlink" title="完美反射法"></a>完美反射法</h3><p>HDR场景下效果很好，但是场景中没有白色就会失效，因为违背了算法的假设前提。</p>
<h3 id="动态阈值法"><a href="#动态阈值法" class="headerlink" title="动态阈值法"></a>动态阈值法</h3><p>效果很好，对单一色块大小不敏感</p>
<h3 id="白点法"><a href="#白点法" class="headerlink" title="白点法"></a>白点法</h3><p>目前普遍应用比较多，效果好，但需要大量校准。<br>统计加权标点法</p>
<h3 id="特殊类型算法"><a href="#特殊类型算法" class="headerlink" title="特殊类型算法"></a>特殊类型算法</h3><p>场景检测-检测人脸 、绿植 、蓝天等。</p>
<h3 id="基于机器学习算法"><a href="#基于机器学习算法" class="headerlink" title="基于机器学习算法"></a>基于机器学习算法</h3><p>FC4 构造基于置信度加权池的全卷积网络<br>CCC<br>FFCC二者在图像的对数色度直方图上学习色调的变化，使用卷积方法进行色彩校正。</p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>Buffer轮转</title>
    <url>/2021/07/11/2021-07-11-%E5%A4%9A%E5%AA%92%E4%BD%93%E7%9B%B8%E6%9C%BA%E7%B3%BB%E5%88%97_Buffer%E8%BD%AE%E8%BD%AC/</url>
    <content><![CDATA[<p>下面是对Android 相机框架Buffer轮转相关知识的解读。</p>
<h2 id="GraphicBuffer"><a href="#GraphicBuffer" class="headerlink" title="GraphicBuffer"></a>GraphicBuffer</h2><p>GraphicBuffer是共享缓冲区，用来承载图片数据，在系统中，图像数据通过buffer形式在显示，相机应用，相机框架，Hal等多个模块间流转交互。</p>
<h2 id="buffer的轮转状态"><a href="#buffer的轮转状态" class="headerlink" title="buffer的轮转状态"></a>buffer的轮转状态</h2><p>一个buffer在创建后，一般会经历Free-&gt;Dequeueed-&gt;Queued-&gt;Acquired-&gt;Free几个状态循环。<br>如下图所示</p>
<span id="more"></span>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/1626016881609.png" alt="1626016881609"></p>
<h2 id="BufferQueue"><a href="#BufferQueue" class="headerlink" title="BufferQueue"></a>BufferQueue</h2><p>BufferQueue创建时候会创建<strong>BufferQueueCore</strong>对象，它是核心缓冲区的管理者，用其作为构造入参创建出生产者BufferQueueProducer对象和消费者BufferQueueConsumer对象。也就是说BufferQueue创建过程其实是建立了一个producer&gt;core&lt;consumer的绑定关系。<br>BufferQueue机制是安卓系统的核心内容，是生产者-消费者设计模式的极好实践。生产者和消费者通常在不同的进程，共享同一块buffer内存，减少数据拷贝。</p>
<h2 id="生产者BufferQueueProducer"><a href="#生产者BufferQueueProducer" class="headerlink" title="生产者BufferQueueProducer"></a>生产者BufferQueueProducer</h2><p>IGraphicBufferProducer接口定义了dequeue Buffer,queueBuffer,requestBuffer等纯虚函数，生产者一般分为BpGraphicBufferProducer和BnIGraphicBufferProducer两个部分，这两部分都实现了IGraphicBufferProducer接口。Bp端通过binder接口调用到Bn端接口，Bn端和BufferQueueCore属于同一个进程。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/1626016849724.png" alt="1626016849724"></p>
<h2 id="消费者BufferQueueConsumer"><a href="#消费者BufferQueueConsumer" class="headerlink" title="消费者BufferQueueConsumer"></a>消费者BufferQueueConsumer</h2><p>IGraphicBufferConsumer接口定义了connect,acquireBuffer,releaseBuffer等纯虚函数，消费者分为BpGraphicBufferConsumer和BnIGraphicBufferConsumer两个部分，这两部分都实现了IGraphicBufferConsumer接口。<br>当生产者queueBuffer到BufferQueue队列时，会通过onFrameAvailable回调来通知消费者。</p>
<h2 id="相机框架轮转"><a href="#相机框架轮转" class="headerlink" title="相机框架轮转"></a>相机框架轮转</h2><p>在java侧创建的Surface在native层有对应的一个Surface对象，相机应用将Surface作为入参创建会话，框架层会对应创建Stream数据流，一个Surface一般对应一路数据流，这个Surface对象作为生产者Bp端对象存储在Stream配置数据中。</p>
<p>下面是相机框架与BufferQueue的一个交互简图。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/camera/1626017649496.png" alt="1626017649496"></p>
]]></content>
      <tags>
        <tag>相机</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenCV准备环境</title>
    <url>/2021/07/28/2021-07-28-OpenCV%E5%87%86%E5%A4%87%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="准备python3"><a href="#准备python3" class="headerlink" title="准备python3"></a>准备python3</h2><p>准备python3环境<br>安装pip，默认是安装好的</p>
<h2 id="安装工具包"><a href="#安装工具包" class="headerlink" title="安装工具包"></a>安装工具包</h2><p>pip install – upgrade setuptools<br>pip install bumpy Matplotlib<br>pip install opencv-python<br>pip install opencv-contrib-python</p>
<span id="more"></span>
<p>在python环境下执行import cv2<br>如果没有报错，说明环境安装成功。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/opencv/opencv.gif" alt="安装操作"></p>
<h2 id="安装pycharm"><a href="#安装pycharm" class="headerlink" title="安装pycharm"></a>安装pycharm</h2><p>官网地址：<a href="https://www.jetbrains.com/pycharm/">https://www.jetbrains.com/pycharm/</a></p>
<p>下面是使用opencv库打开一张图片示例</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/opencv/1627485476789.png" alt="dog图"></p>
]]></content>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网配置</title>
    <url>/2021/08/01/2021-08-01-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><strong>linux系统环境</strong>：CentOS linux</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1627816253376.png" alt="1627816253376"></p>
<p><strong>SS客户端</strong>：我自己下载使用的是<a href="https://github.com/shadowsocks/shadowsocks-windows/releases">Windows</a>4.3.3.0版本，手机端用的<a href="https://github.com/shadowsocks/shadowsocks-android/releases">Android</a>5.2.2版本</p>
<span id="more"></span>

<h2 id="配置科学上网"><a href="#配置科学上网" class="headerlink" title="配置科学上网"></a>配置科学上网</h2><p>命令1：wget –no-check-certificate -O shadowsocks-all.sh <a href="https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-all.sh</a></p>
<p>命令2：chmod +x shadowsocks-all.sh</p>
<p>命令3：./shadowsocks-all.sh 2&gt;&amp;1 | tee shadowsocks-all.log</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1627816125887.png" alt="1627816125887"></p>
<p>我选择的是2）ShadowsocksR 安装成功了，之前选择1）一直安装不成功</p>
<h2 id="yum命令报错及解决办法"><a href="#yum命令报错及解决办法" class="headerlink" title="yum命令报错及解决办法"></a>yum命令报错及解决办法</h2><p>执行yum命令时报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File &quot;/usr/bin/yum&quot;, line 30</span><br><span class="line">except KeyboardInterrupt, e:</span><br><span class="line">                       ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p><strong>原因</strong>：这是因为yum采用Python作为命令解释器，这可以从/usr/bin/yum文件中第一行#!/usr/bin/python发现。python2.X版本与3.0版本之间存在语法不一致问题。CentOS 7自带的yum采用的是python2.7，当系统将python升级到3.4后，出现语法解释错误。</p>
<p>这是因为yum采用Python作为命令解释器，这可以从/usr/bin/yum文件中第一行#!/usr/bin/python发现。python2.X版本与3.0版本之间存在语法不一致问题。而CentOS 7自带的yum采用的是python2.7，当系统将python升级到3.4后，出现语法解释错误。</p>
<p>解决办法：<br>在设置里更改解释器设置，即修改/usr/bin/yum文件，指定使用python2.7作为yum的解释器：</p>
<p>执行： vi /usr/bin/yum </p>
<p>将第一行”#!/usr/bin/python” 改为 “#!/usr/bin/python2.7”即可。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1627816749456.png" alt="1627816749456"></p>
<p>安装软件时可能出现另一种报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Downloading packages:</span><br><span class="line">   File &quot;/usr/libexec/urlgrabber-ext-down&quot;, line 28</span><br><span class="line">     except OSError, e:</span><br><span class="line">                   ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>

<p>问题与前面一样，解决办法也是一样的：</p>
<p>vi /usr/libexec/urlgrabber-ext-down</p>
<p>将第一行”#!/usr/bin/python” 改为 “#!/usr/bin/python2.7”即可。</p>
<p><img src="https://gitee.com/hangliebe/hangliebe/raw/master/img/others/1627816788689.png" alt="1627816788689"></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
